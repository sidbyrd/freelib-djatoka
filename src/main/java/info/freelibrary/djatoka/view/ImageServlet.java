
package info.freelibrary.djatoka.view;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import gov.lanl.adore.djatoka.openurl.OpenURLJP2KService;
import info.freelibrary.djatoka.Constants;
import info.freelibrary.djatoka.iiif.*;
import info.freelibrary.djatoka.util.CacheUtils;
import info.freelibrary.djatoka.util.URLEncode;
import info.freelibrary.util.*;
import nu.xom.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.IIOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.*;

public class ImageServlet extends HttpServlet implements Constants {

    /**
     * The <code>ImageServlet</code>'s <code>serialVersionUID</code>.
     */
    private static final long serialVersionUID = -4142816720756238591L;

    private static final Logger LOGGER = LoggerFactory.getLogger(ImageServlet.class);

    private static final ObjectMapper MAPPER = new ObjectMapper();

    private static final String RESOLVE_METADATA_QUERY =
            "?url_ver=Z39.88-2004&rft_id={}&svc_id=info:lanl-repo/svc/getMetadata";

    private static final String RESOLVE_IMAGE_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.level={}&svc.rotate={}&svc.region={}";

    private static final String RESOLVE_REGION_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.region={}&svc.scale={}&svc.rotate={}";

    private static final String XML_TEMPLATE = "/WEB-INF/metadata.xml";

    /** Max dimension of generated tiles. I can't believe this wasn't already a constant anywhere! */
    private static final int TILE_SIZE = 256;
    private static final int TILE_LOG2 = log2(TILE_SIZE);

    /** PairTree tile cache, where we move tiles generated by Djatoka from its temp cache dir */
    private static PairtreeRoot tileCache = null;

    /**
     * a locally accessible URL to the root of the server this webapp is running on
     * optional: leave null to just use the same URL that externally connecting clients use.
     * Useful if e.g. externally visible on https://server.com, but internally also at http://localhost:8080
     * */
    private static String internalServer = null;

    /**
     * Set to return error if served an option or property setting that I have
     * noticed OpenSeaDragon never uses. Can help keep possible accepted parameters finite.
     * */
    private static boolean requireOsdStyle = true;

    /**
     * Set to require region and scaling settings to align on power-of-two boundaries corresponding
     * to the zoom level desired (and legal for the requested image). Dispatches djatoka request
     * using the svc.level option for faster and higher quality results, and returns an error to
     * any requests for region+scale that doesn't align properly with zoom levels. Compatible with
     * OpenSeaDragon. Reduces possible space of parameters to something finite (and pre-generatable).
     */
    private static boolean requireLevels = true;

    /**
     * JP2 images has a certain number of zoom settings encoded in them. If requireLevels==true, set
     * this to allow requests for images zoomed farther out than level 1, which is the normal minimum.
     */
    private static int minZoomLevel = 1;

    /** path this whole webapp is at, relative to server root */
    private static String contextPath = null;

    /** path the resolver servlet is at, relative to contextPath */
    private static String resolverPath = null;

    /** recently accessed Height, Width, and Level lookups, keyed by identifier */
    private static Map<String, int[]> recentHWL = null;
    private static final int RECENT_HWL_SIZE = 500;

    /**
     * recently accessed tile filenames, keyed by URL
     * value is pair of HTTP status code and filename (or error message if code != SC_OK)
     */
    private static Map<String, Map.Entry<Integer, String>> recentTiles = null;
    private static final int RECENT_TILES_SIZE = 50000;

    /** for logging */
    private static final DecimalFormat df = new DecimalFormat("######.00000");

    @Override
    protected void doGet(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws ServletException, IOException {
        final IIIFRequest iiif = (IIIFRequest) aRequest.getAttribute(IIIFRequest.KEY);

	    if (iiif == null) {
            aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "IIIF format required");
            return;
	    }
        final String id = iiif.getIdentifier();
        if (id==null) {
            aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "identifier required");
            return;
        }
        if (iiif instanceof InfoRequest) {
            try {
                final int[] hwl = getHeightWidthAndLevels(id, aRequest, aResponse);
                final ImageInfo info = new ImageInfo(id, hwl[0], hwl[1], hwl[2]);
                final ServletOutputStream outStream = aResponse.getOutputStream();

                if (iiif.getExtension().equals("xml")) {
                    info.toStream(outStream);
                } else {
                    final String server = getServer(aRequest); // needs to be the externally-accessible address

                    // per IIIF spec, the prefix includes the contextPath already.
                    final String prefix = iiif.getServicePrefix();

                    info.addFormat("jpg"); // FIXME: Configurable options

                    outStream.print(info.toJSON(server, prefix));
                }

                outStream.close();
            } catch (final FileNotFoundException details) {
                aResponse.sendError(HttpServletResponse.SC_NOT_FOUND, id + " not found");
            }
        } else if (iiif instanceof ImageRequest) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Request is handled via the IIIFRequest shim");
            }

            // see if we already have a cached response: same file served, lots less mucking about with strings
            final String uri=aRequest.getRequestURI();
            Map.Entry<Integer, String> response = recentTiles.get(uri);

            if (response != null) {
                // serve the cached file or error
                LOGGER.debug("serving cached response with code {}",response.getKey());
                serveAndCache(response, aRequest, aResponse);
            } else {
                final int[] hwl = getHeightWidthAndLevels(id, aRequest, aResponse); // already cached if user requested metadata first
                final ImageRequest imageRequest = (ImageRequest) iiif;
                final Size scale = imageRequest.getSize();
                final int sh = scale.getHeight(); // with OpenSeaDragon, is always -1. Already guaranteed both are not -1.
                final int sw = scale.getWidth();
                Region region = imageRequest.getRegion();
                region.setFullsizeDims(hwl[1], hwl[0]);
                int x = region.getX(); // all Region fields already guaranteed positive if region!="full"
                int y = region.getY();
                int rh = region.getHeight();
                int rw = region.getWidth();
                final float rotation = imageRequest.getRotation();
                int level = -1; // no level *yet*

                if (x > hwl[1] || y > hwl[0]) {
                    serveAndCache(HttpServletResponse.SC_BAD_REQUEST, "region x/y coords not within image bounds", aRequest, aResponse);
                    return;
                }

                // if configured, don't allow requests that aren't expected when using OpenSeaDragon
                // Ensures that no tiles are generated (and cached forever!) with odd settings we didn't intend to serve up.
                if (requireOsdStyle) {
                    if (sw != -1 && sh != -1) { // avoid altered aspect ratio.
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "may not specify both scaled dimensions");
                    } else if (region.usesPercents()) { // percents use float math and make level calculations imprecise.
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "region may not use percent");
                    } else if (rotation != 0f) { // OSD rotates the HTML canvas instead
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_NOT_IMPLEMENTED,
                                "rotation must be 0");
                    }
                    if (response != null) {
                        serveAndCache(response, aRequest, aResponse);
                        return;
                    }
                }

                // We bothered to encode our JP2s with these nifty high-quality preset levels. Let's use them!
                // Even though IIIF protocol only speaks regions, good clients request them at standard power-of-two scales
                // and boundaries that can be translated into levels.
                if (requireLevels) {

                    // this requires that the scaled output tile size be standard.
                    if (sw > TILE_SIZE || sh > TILE_SIZE) {
                        serveAndCache(HttpServletResponse.SC_BAD_REQUEST, "max tile size is " + TILE_SIZE, aRequest, aResponse);
                        return;
                    }

                    // Find the side length of the region in the image being requested.
                    int rs; // region square side length (if edges of image didn't interfere)
                    int l; // sqrt(rs), which works like a psuedo-level. We convert to a real Djatoka "level" at the end.

                    if (rw < hwl[1]-x) { // if region width isn't against the edge, it is the full square width
                        rs=rw;
                        l = log2(rs);
                    } else if (rh < hwl[0]-y) {  // if region height isn't against the edge, it is the full square height
                        rs=rh;
                        l = log2(rs);
                    } else if (sw > 0 && sw < TILE_SIZE) { // if scale width is less than TILE_SIZE, can extract rs from its value
                        rs = TILE_SIZE*(hwl[1]-x)/sw; // sw = ceil[ TILE_SIZE * (width-x) / rs ]  => rs = floor[ TILE_SIZE * (width-x) / sw ]
                        l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                        rs = 1<<l; // rs = 2^l
                    } else if (sh > 0 && sh < TILE_SIZE) { // if scale height is less than TILE_SIZE, can extract rs from its value
                        rs = TILE_SIZE*(hwl[0]-y)/sh; // sh = ceil[ TILE_SIZE * (height-y) / rs ]  => rs = floor[ TILE_SIZE * (height-y) / sh ]
                        l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                        rs = 1<<l; // rs = 2^l
                    } else { // no exact boundary--just use the first one bigger than will fit in given source region
                        final int rbig = Math.max(rw, rh);
                        l = log2(rbig) + (isExactPowerOf2(rbig)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                        rs = 1<<l; // rs = 2^l
                    }

                    // At this point, we have rs = 2^l.
                    // In Djatoka-world, rs = TILESIZE * 2^(maxImageLevels -level) == 2^(maxImageLevels -level +log2(TILESIZE)). So solve for "level".
                    level = hwl[2] + TILE_LOG2 - l;
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Level calculated: rs="+rs+", l="+l+", level="+level);
                    }

                    // Zoom levels < 1 are not legal in Djatoka, but they may still be requested for thumbnails or tiny screens.
                    if (level < 1) {
                        if (level >= minZoomLevel) {
                            level = -1; // just do a standard level-less Region request instead, as long as the other conditions still hold.
                        } else {
                            serveAndCache(HttpServletResponse.SC_BAD_REQUEST,
                                    "region and scale correspond to zoom level "+level+" below allowed min of "+minZoomLevel, aRequest, aResponse);
                            return;
                        }
                    }

                    // calculate what both scale dimensions should be, even if they are given as -1 for default.
                    final int explicitSh = Math.min(Math.round((float)(TILE_SIZE*(hwl[0]-y))/(float)rs),TILE_SIZE);
                    final int explicitSw = Math.min(Math.round((float)(TILE_SIZE*(hwl[1]-x))/(float)rs),TILE_SIZE);

                    // Validate that the request used standard power-if-two region and scale, so our level calculations were valid.
                    // Ensures that no tiles are generated (and cached forever!) at odd dimensions that we didn't intend to serve up.
                    if (level > hwl[2]) {
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "region and scale correspond to zoom level "+level+" above this image's max of "+hwl[2]);
                    } else if (x % rs != 0 || y % rs != 0) {
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "region x and y coords "+x+","+y+" must fall evenly on boundary of "+rs+" when zoom level is"+level);
                    } else if (rh != Math.min(hwl[0]-y, rs)) {
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "region height "+rh+" should be "+Math.min(hwl[0]-y, rs)+" when region size is "+rs
                                +" and bottom edge is "+Integer.toString(hwl[0]-y)+" away");
                    } else if (rw != Math.min(hwl[1]-x, rs)) {
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "region width "+rw+" should be "+Math.min(hwl[1]-x, rs)+" when region size is "+rs
                                 +" and right edge is "+Integer.toString(hwl[1]-x)+" away");
                    } else if (sh != -1 && Math.abs(explicitSh - sh) > 1) { // rarely--only at level < 1—-OSD rounds up when should dn.
                        final float raw = (float)(TILE_SIZE*(hwl[0]-y))/(float)rs;
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "scaled height "+sh+" should be "+explicitSh+" when right edge is "+df.format(raw)
                                +" (~"+Math.round(raw)+" away after scaling)");
                    } else if (sw != -1 && Math.abs(explicitSw - sw) > 1) {
                        final float raw = (float)(TILE_SIZE*(hwl[1]-x))/(float)rs;
                        response = new AbstractMap.SimpleImmutableEntry<Integer,String>(HttpServletResponse.SC_BAD_REQUEST,
                                "scaled width "+sw+" should be "+explicitSw+" when bottom edge is "+df.format(raw)
                                +" (~"+Math.round(raw)+" away after scaling)");
                    }
                    if (response != null) {
                        if (LOGGER.isDebugEnabled()) {
                            LOGGER.debug(response.getValue());
                        }
                        serveAndCache(response, aRequest, aResponse);
                        return;
                    }

                    // make scale dimensions explicit -- it's required when using level (and overwrites minor OSD rounding flaws)
                    scale.setExplicit(explicitSw, explicitSh);
                }
                // All good! Serve the image tile, ideally from cache
                String cachedFilename = serveImageWithCaching(id, level, region, scale, rotation, aRequest, aResponse);
                if (cachedFilename != null) {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Adding served image filename to recentTiles cache:\n{} -> {}", aRequest.getRequestURI(), cachedFilename);
                    }
                    recentTiles.put(aRequest.getRequestURI(), new AbstractMap.SimpleImmutableEntry<Integer, String>(HttpServletResponse.SC_OK, cachedFilename));
                } else if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Not adding served image filename to recentTiles cache:\n{} -> null", aRequest.getRequestURI());
                }
            }
        } else {
            aResponse.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, "unrecognized IIIF message type");
        }
    }

    /**
     * Serves the prepared response and caches it
     * @param code HTTP response code
     * @param message if code==200: the file path of a JPG file to serve. Must exist!
     *                if code!=200: message text to display on error page
     * @param aRequest the request being served
     * @param aResponse the response to serve
     * @throws IOException if serving response
     */
    private static void serveAndCache(int code, String message,
                                      HttpServletRequest aRequest, HttpServletResponse aResponse) throws IOException {
        serveAndCache(new AbstractMap.SimpleImmutableEntry<Integer, String>(code, message), aRequest, aResponse);
    }
    private static void serveAndCache(Map.Entry<Integer, String> response,
                                      HttpServletRequest aRequest, HttpServletResponse aResponse) throws IOException {
        if (response.getKey().equals(HttpServletResponse.SC_OK)) {
            try {
                serveJpgFile(response.getValue(), aResponse);
            } catch (IOException e) {
                LOGGER.warn("couldn't serve file "+response.getValue()+" : "+e.getMessage());
                aResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "couldn't serve file");
            }
        } else {
            aResponse.sendError(response.getKey(), response.getValue());
        }
        recentTiles.put(aRequest.getRequestURI(), response);
    }

    /**
     * Quick function to take log base 2 of an integer.
     * @param n int to take log2 of
     * @return log2 of the int.
     */
    private static int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    /**
     * Quick function to determine whether an int is an exact power of 2
     * @param n number to check
     * @return whether n is a power of 2
     */
    private static boolean isExactPowerOf2(int n) {
        return (n & (n-1)) == 0;
    }

    @Override
    public void init() throws ServletException {
        final InputStream is = getClass().getResourceAsStream("/" + PROPERTIES_FILE);

        if (is != null) {
            final Properties props = new Properties();
            try {
                props.loadFromXML(is);
            } catch (final IOException details) {
                if (LOGGER.isWarnEnabled()) {
                    LOGGER.warn("Unable to load properties file: {}", details.getMessage());
                }
            } finally {
                IOUtils.closeQuietly(is);
            }

            // cache dir
            String cacheDir;
            if (props.containsKey(VIEW_CACHE_DIR)) {
                cacheDir = props.getProperty(VIEW_CACHE_DIR);
            } else {
                // If we couldn't get cache from config, fall back to tmpdir
                cacheDir = System.getProperty("java.io.tmpdir");
            }
            try {
                tileCache = new PairtreeRoot(cacheDir);
            } catch (IOException details) {
                // properly configured cache is mandatory
                LOGGER.error("Unable to load tile cache directory: {}", details.getMessage());
                throw new ServletException(details.getMessage());
            }

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Cache directory set to {}", cacheDir);
            }

            // general properties
            if (props.containsKey(INTERNAL_SERVER)) {
                internalServer = props.getProperty(INTERNAL_SERVER);
            }
            if (props.containsKey(REQUIRE_OSD_STYLE)) {
                requireOsdStyle = props.getProperty(REQUIRE_OSD_STYLE).equals("true");
            }
            if (props.containsKey(REQUIRE_LEVELS)) {
                requireLevels = props.getProperty(REQUIRE_LEVELS).equals("true");
            }
            if (props.containsKey(REQUIRE_LEVELS_MIN)) {
                try {
                    minZoomLevel = Integer.parseInt(props.getProperty(REQUIRE_LEVELS_MIN));
                } catch (NumberFormatException e) {
                    LOGGER.warn("Property "+REQUIRE_LEVELS_MIN+" was not a number; using "+ minZoomLevel +" instead");
                }
                if (minZoomLevel > 1) {
                    LOGGER.warn("Property "+REQUIRE_LEVELS_MIN+"="+minZoomLevel+" was clipped to a max of 1");
                    minZoomLevel = 1;
                }
            }
        }

        // get the base URL that this whole webapp is server at (relative to server root)
        contextPath = getServletContext().getContextPath();
        LOGGER.debug("IIIF servlet using context path of {}", contextPath);

        // get the (first) URL that the servlet named "resolver" (in web.xml) is served at, relative to contextPath
        try {
            resolverPath = getServletContext().getServletRegistration("resolver").getMappings().iterator().next();
        } catch (UnsupportedOperationException e) {
            LOGGER.error("Unable to get servlet registration for 'resolver': {}", e.getMessage());
        } catch (NoSuchElementException e) {
            LOGGER.error("No registrations found for servlet 'resolver': {}", e.getMessage());
        }
        if (resolverPath == null) {
            // didn't work? Maybe we can fake something.
            resolverPath = "/resolver";
        }
        LOGGER.debug("IIIF servlet using resolver URL of {}", resolverPath);

        // init lookup LRU caches for oft-repeated calculations
        recentHWL = Collections.synchronizedMap(new LruCache<String, int[]>(RECENT_HWL_SIZE));
        recentTiles = Collections.synchronizedMap(new LruCache<String, Map.Entry<Integer, String>>(RECENT_TILES_SIZE));
    }

    /* this is incorrect for 2 reasons:
     * 1) HEAD should return the exact same headers as GET, per HTTP spec.
     * 2) This returns dims of entire full res image, no matter what piece is requested.
     *    In fact, why does it even return dims? I don't see it in IIIF spec or anything.
     * Fortunately, this method is never called in practice using OpenSeaDragon.
     * For reference, the real GET returns
     *  - Cache-Control (on images only [not metadata], if cached already in PairTree tile cache)
     *  - Content-Type (image/jpeg or text/json, set by IIIFServletFilter)
     *  - Content-Length
    @Override
    protected void doHead(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws ServletException, IOException {
        Logger.debug("IIIF servlet: got HEAD on "+aRequest.getRequestURI());
        try {
            final int[] dimensions = getHeightWidthAndLevels(aRequest, aResponse);

            // TODO: add a content length header too
            if (!aResponse.isCommitted()) {
                aResponse.addIntHeader("X-Image-Height", dimensions[0]);
                aResponse.addIntHeader("X-Image-Width", dimensions[1]);

                aResponse.setStatus(HttpServletResponse.SC_OK);
            }
        } catch (final FileNotFoundException details) {
            aResponse.sendError(HttpServletResponse.SC_NOT_FOUND);
        }
    }
    */

    @Override
    protected long getLastModified(final HttpServletRequest aRequest) {
        // TODO: really implement this using our cached files?
        return super.getLastModified(aRequest);
    }

    private int[] getHeightWidthAndLevels(final String id, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {

        if (recentHWL.containsKey(id)) {
            return recentHWL.get(id);
        }

        int width = 0, height = 0, levels = 0;

        OutputStream outStream = null;
        InputStream inStream = null;

        try {
            final PairtreeObject cacheObject = tileCache.getObject(id);
            final String filename = PairtreeUtils.encodeID(id);
            final File xmlFile = new File(cacheObject, filename + ".xml");

            if (xmlFile.exists() && xmlFile.length() > 0) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Reading XML metadata file: " + xmlFile.getAbsolutePath());
                }

                final Document xml = new Builder().build(xmlFile);
                final Element root = xml.getRootElement();
                final Element sElement = root.getFirstChildElement("Size");
                final String wString = sElement.getAttributeValue("Width");
                final String hString = sElement.getAttributeValue("Height");
                final Element lElement = root.getFirstChildElement("Levels");

                width = wString.equals("") ? 0 : Integer.parseInt(wString);
                height = hString.equals("") ? 0 : Integer.parseInt(hString);

                if (lElement != null) {
                    try {
                        levels = Integer.parseInt(lElement.getValue());
                    } catch (final NumberFormatException details) {
                        if (LOGGER.isErrorEnabled()) {
                            LOGGER.error("{} doesn't look like an integer level", lElement.getValue());
                        }

                        levels = 0;
                    }
                }

                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Returning width/height/levels: {}/{}/{}", width, height, levels);
                }
            } else {
                //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles

                final ServletContext context = getServletContext();
                inStream = context.getResource(XML_TEMPLATE).openStream();

                if (xmlFile.exists()) {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("XML metadata file exists: {}", xmlFile);
                    }

                    if (!xmlFile.delete() && LOGGER.isWarnEnabled()) {
                        LOGGER.warn("File not deleted: {}", xmlFile);
                    }
                }

                outStream = new FileOutputStream(xmlFile);

                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Creating new xml metadata file: " + xmlFile.getAbsolutePath());
                }

                final Document xml = new Builder().build(inStream);
                final Serializer serializer = new Serializer(outStream);
                final String safeID = URLEncode.pathSafetyEncode(id);

                try {
                    String server;
                    if (internalServer != null) {
                        // refer to this server at a pre-configured internal URL, e.g. http://localhost:8080
                        server = internalServer;
                    } else {
                        // refer to this server at the same publicly addressable name the user just did
                        server = getServer(aRequest);
                    }
                    // construct URL with context path because we'll be dispatching it externally to this webapp.
                    final URL url = new URL(server + contextPath
                        + resolverPath + StringUtils.format(RESOLVE_METADATA_QUERY, safeID));

                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Querying image metadata: {}", url);
                    }

                    // issue JSON http request to myself and parse the output as JSON.
                    // Ideally, I could just call the code directly, but the config and init setup for the
                    //   Djatoka code isn't quite worth messing with.
                    final JsonNode json = MAPPER.readTree(url.openStream());

                    // Pull out relevant info from our metadata service
                    width = json.get("width").asInt();
                    height = json.get("height").asInt();
                    levels = json.get("levels").asInt();

                    final Element root = xml.getRootElement();
                    final Element sElement = root.getFirstChildElement("Size");
                    final Attribute wAttribute = sElement.getAttribute("Width");
                    final Attribute hAttribute = sElement.getAttribute("Height");
                    final Element lElement = root.getFirstChildElement("Levels");

                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Width: {}; Height: {}; Level: {}", width, height, levels);
                    }

                    // Save it in our xml file for easier access next time
                    wAttribute.setValue(Integer.toString(width));
                    hAttribute.setValue(Integer.toString(height));
                    lElement.appendChild(Integer.toString(levels));

                    serializer.write(xml);
                    serializer.flush();
                } catch (final IIOException details) {
                    if (details.getCause().getClass().getSimpleName().equals("FileNotFoundException")) {
                        throw new FileNotFoundException(id + " not found");
                    } else {
                        if (LOGGER.isErrorEnabled()) {
                            LOGGER.error("[{}] " + details.getMessage(), id, details);
                        }

                        throw details;
                    }
                }
            }
        } catch (final ParsingException details) {
            aResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, details.getMessage());
        } finally {
            IOUtils.closeQuietly(outStream);
            IOUtils.closeQuietly(inStream);
        }

        int[] result = new int[] { height, width, levels };
        recentHWL.put(id, result);
        return result;
    }

    /**
     * Serve a JPEG file's contents, given its full path
     * @param imagePath path to a JPG image file. File must exist!
     * @param aResponse response to serve the bits on
     * @throws IOException if couldn't serve file
     */
    private static void serveJpgFile(final String imagePath, final HttpServletResponse aResponse) throws IOException {
        final File imageFile = new File(imagePath);
        final ServletOutputStream outStream = aResponse.getOutputStream();

        aResponse.setHeader("Content-Length", "" + imageFile.length());
        aResponse.setHeader("Cache-Control", "public, max-age=4838400");
        aResponse.setContentType("image/jpg");

        IOUtils.copyStream(imageFile, outStream);
        IOUtils.closeQuietly(outStream);
    }

    /**
     * Serves an image with requested params. Uses a tile in the tilecache already if possible.
     * Otherwise, forward the request to Djatoka OpenURL to make and serve the tile, then move
     * Djatoka's generated image file from its cache into our tilecache for next time.
     *
     * Design note: it would be great to have this return a Pair<Integer,String> response like
     * the code higher up than this, but unless I want to catch what OpenURL serves and write it to
     * disk myself to re-serve later (and also somehow parse out whatever errors it serves!),
     * it's easier to just forgo the opportunity to cache any error messages that occur in here,
     * say that instead of returning a response to be served, this method serves directly, and
     * return only a filename on success.
     *
     * @param aID identifier of image
     * @param aLevel level of sample region
     * @param aRegion sample region
     * @param aScale scale/size of output tile
     * @param aRotation rotation of output tile
     * @param aRequest HTTP request being fulfilled
     * @param aResponse HTTP response to serve on
     * @return the filename of a locally cached copy of the image, or null
     * @throws IOException if couldn't read tilecache or dispatch request to OpenURL successfully
     * @throws ServletException if couldn't dispatch request to OpenURL successfully
     */
    private String serveImageWithCaching(final String aID, final int aLevel, final Region aRegion, final Size aScale,
                                                      final float aRotation, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {
        final PairtreeObject cacheObject = tileCache.getObject(aID);
        final String fileName = CacheUtils.getFileName(aLevel, aRegion, aScale, aRotation);
        final File imageFile = new File(cacheObject, fileName);

        if (imageFile.exists()) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} serving from Pairtree cache", imageFile);
            }

            serveJpgFile(imageFile.getAbsolutePath(), aResponse);
            return imageFile.getAbsolutePath();
        } else {
            //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} not found in cache", imageFile);
            }

            serveDjatokaImage(aID, aLevel, aRegion, aScale, aRotation, aRequest, aResponse);
            return cacheNewImage(aRequest, aID + "_" + fileName, imageFile);
        }
    }

    /**
     * Builds the correct query string and dispatches to the OpenURL/Djatoka system to fetch, adjust, and serve
     * the image. As a side effect, the Djatoka system stores the filename in the session object.
     * @param aID identifier of image
     * @param aLevel level of sample region
     * @param aRegion sample region
     * @param aScale scale/size of output tile
     * @param aRotation rotation of output tile
     * @param aRequest HTTP request being fulfilled
     * @param aResponse HTTP response to serve on
     * @throws IOException if couldn't dispatch request to OpenURL successfully
     * @throws ServletException if couldn't dispatch request to OpenURL successfully
     */
    private void serveDjatokaImage(final String aID, final int aLevel, final Region aRegion, final Size aScale,
                                   final float aRotation, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {
        final String safeID = URLEncode.pathSafetyEncode(aID);
        RequestDispatcher dispatcher;
        String[] values;
        String url;

        // Cast floats as integers because that's what djatoka expects
        // Construct URLs without contextPath because we'll be dispatching them *within* this webapp.
        if (aLevel > 0) {
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, String.valueOf(aLevel), Integer.toString((int) aRotation),
                    aRegion.toDjatokaString(aLevel, aScale) };
            url = resolverPath +StringUtils.format(RESOLVE_IMAGE_QUERY, values);
        } else {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Image requested with no level specified: id={} region={} scale={}", aID, aRegion, aScale);
            }
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, aRegion.toDjatokaString(aLevel, aScale), aScale.toDjatokaString(),
                    Integer.toString((int) aRotation) };
            url = resolverPath +StringUtils.format(RESOLVE_REGION_QUERY, values);
        }

        // Right now we just let the OpenURL interface do the work
        dispatcher = aRequest.getRequestDispatcher(url);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Image requested: {} - {}", aID, url);
        }

        dispatcher.forward(aRequest, aResponse);
    }

    /**
     * For an image that was just served by the OpenURL/Djatoka system, move its file from their cache to ours.
     * @param aRequest the incoming image request that Djatoka just fulfilled
     * @param aKey the image ID + underscore + and the combined display parameters, which match what Djatoka just served.
     * @param aDestFile the destination file in the tile cache PairTree to which to move the served image tile.
     * @return the filename of a locally cached copy of the image, or null
     */
    private String cacheNewImage(final HttpServletRequest aRequest, final String aKey, final File aDestFile) {
        final HttpSession session = aRequest.getSession();
        // path to temp file that the djatoka code saved in its temp cache (not the freelib tile cache!)
        final String fileName = (String) session.getAttribute(aKey);

        if (fileName != null) {
            // name by which to reference the cached file when talking to OpenURL code
            final String cacheName = (String) session.getAttribute(fileName);
            final File cachedFile = new File(fileName);

            // This moves the newly created file from the adore-djatoka cache
            // to the freelib-djatoka tile cache (which is pure-FS/Pairtree-based)
            if (cachedFile.exists() && aDestFile != null) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Renaming cache file from {} to {}", cachedFile, aDestFile);
                }

                if (!cachedFile.renameTo(aDestFile) && LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Unable to move cache file: {}", cachedFile);
                } else {
                    // This is the temp file cache used by the OpenURL layer
                    if (!OpenURLJP2KService.removeFromTileCache(cacheName) && LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Unable to remove OpenURL cache file link: {}", fileName);
                    } else {
                        session.removeAttribute(aKey);
                        session.removeAttribute(fileName);
                        return aDestFile.getAbsolutePath();
                    }
                }
            } else if (LOGGER.isWarnEnabled() && !cachedFile.exists()) {
                LOGGER.warn("Session had a cache file ({}), but it didn't exist", cachedFile.getAbsoluteFile());
            } else if (LOGGER.isWarnEnabled()) {
                LOGGER.warn("Location for destination cache file was null");
            }
        } else if (LOGGER.isWarnEnabled()) {
            // If you're wondering why you found your way to this error, it's because something in the Djatoka code
            // had an error. Maybe try turning on debug logging for gov.lanl.* or finding out what URL was
            // dispatched to and loading it directly yourself to see what it reports.
            LOGGER.warn("Couldn't cache ({} = {}); session lacked new image information", aKey, aDestFile
                    .getAbsolutePath());
        }
        return null;
    }

    /**
     * Returns a URL to the root of the server that a request was sent to
     * @param aRequest incoming request
     * @return externally visible address of the server, with explicit port number
     */
    private static String getServer(final HttpServletRequest aRequest) {
        final StringBuilder server = new StringBuilder();
        server.append(aRequest.getScheme()).append("://");
        server.append(aRequest.getServerName()).append(":");
        server.append(aRequest.getServerPort());
        return server.toString();
    }

    /**
     * Small utility class to override one method in LinkedHashMap, and make sure the right
     * initializer params get called. This allows it to be used as an LRU cache.
     * @param <K>Key type
     * @param <V>Value type
     */
    private class LruCache<K,V> extends LinkedHashMap<K,V> {
        private final int maxEntries;
        public LruCache(final int maxEntries) {
            super(maxEntries + 1,0.75f, true);
            this.maxEntries = maxEntries;
        }
        @Override
        protected boolean removeEldestEntry(final Map.Entry<K,V> eldest) {
            return super.size() > maxEntries;
        }
    }
}
