
package info.freelibrary.djatoka.view;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import gov.lanl.adore.djatoka.openurl.OpenURLJP2KService;
import info.freelibrary.djatoka.Constants;
import info.freelibrary.djatoka.iiif.*;
import info.freelibrary.djatoka.util.CacheUtils;
import info.freelibrary.djatoka.util.URLEncode;
import info.freelibrary.util.*;
import javafx.util.Pair;
import nu.xom.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.IIOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.*;

public class ImageServlet extends HttpServlet implements Constants {

    /**
     * The <code>ImageServlet</code>'s <code>serialVersionUID</code>.
     */
    private static final long serialVersionUID = -4142816720756238591L;

    private static final Logger LOGGER = LoggerFactory.getLogger(ImageServlet.class);

    private static final ObjectMapper MAPPER = new ObjectMapper();

    private static final String RESOLVE_METADATA_QUERY =
            "?url_ver=Z39.88-2004&rft_id={}&svc_id=info:lanl-repo/svc/getMetadata";

    private static final String RESOLVE_IMAGE_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.level={}&svc.rotate={}&svc.region={}";

    private static final String RESOLVE_REGION_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.region={}&svc.scale={}&svc.rotate={}";

    private static final String XML_TEMPLATE = "/WEB-INF/metadata.xml";

    /** Max dimension of generated tiles. I can't believe this wasn't already a constant anywhere! */
    private static final int TILE_SIZE = 256;
    private static final int TILE_LOG2 = log2(TILE_SIZE);

    /** PairTree tile cache, where we move tiles generated by Djatoka from its temp cache dir */
    private static PairtreeRoot tileCache = null;

    /** a locally accessible URL to the root of the server this webapp is running on
     * optional: leave null to just use the same URL that externally connecting clients use.
     * Useful if e.g. externally visible on https://server.com, but internally also at http://localhost:8080 */
    private static String internalServer = null;
    /** path this whole webapp is at, relative to server root */
    private static String contextPath = null;
    /** path the resolver servlet is at, relative to contextPath */
    private static String resolverPath = null;

    /** recently accessed Height, Width, and Level lookups, keyed by identifier */
    private static Map<String, int[]> recentHWL = null;
    private static final int RECENT_HWL_SIZE = 500;

    /**
     * recently accessed tile filenames, keyed by URL
     * value is HTTP status code, filename (or error message if code != SC_OK)
     */
    private static Map<String, Pair<Integer, String>> recentTiles = null;
    private static final int RECENT_TILES_SIZE = 50000;
    private static final String TILE_FAIL = ""; /// value if key URL causes an error response

    /** for logging */
    private static final DecimalFormat df = new DecimalFormat("######.00000");

    @Override
    protected void doGet(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws ServletException, IOException {

        Pair<Integer, String> response = null;
        final IIIFRequest iiif = (IIIFRequest) aRequest.getAttribute(IIIFRequest.KEY);
        String id;

	    if (iiif == null) {
            response = new Pair<Integer, String>(HttpServletResponse.SC_BAD_REQUEST, "IIIF format required");
	    } else {
            id = iiif.getIdentifier();
            if (id==null) {
                response = new Pair<Integer, String>(HttpServletResponse.SC_BAD_REQUEST, "identifier required");
            } else {

                if (iiif instanceof InfoRequest) {
                    try {
                        final int[] hwl = getHeightWidthAndLevels(id, aRequest, aResponse);
                        final ImageInfo info = new ImageInfo(id, hwl[0], hwl[1], hwl[2]);
                        final ServletOutputStream outStream = aResponse.getOutputStream();

                        if (iiif.getExtension().equals("xml")) {
                            info.toStream(outStream);
                        } else {
                            final String server = getServer(aRequest); // needs to be the externally-accessible address

                            // per IIIF spec, the prefix includes the contextPath already.
                            final String prefix = iiif.getServicePrefix();

                            info.addFormat("jpg"); // FIXME: Configurable options

                            outStream.print(info.toJSON(server, prefix));
                        }

                        outStream.close();
                    } catch (final FileNotFoundException details) {
                        aResponse.sendError(HttpServletResponse.SC_NOT_FOUND, id + " not found");
                    }
                } else if (iiif instanceof ImageRequest) {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Request is handled via the IIIFRequest shim");
                    }

                    final int[] hwl = getHeightWidthAndLevels(id, aRequest, aResponse); // already cached if user requested metadata first
                    final ImageRequest imageRequest = (ImageRequest) iiif;
                    final Size scale = imageRequest.getSize();
                    final int sh = scale.getHeight(); // with OpenSeaDragon, is always -1. Already guaranteed both are not -1.
                    final int sw = scale.getWidth();
                    Region region = imageRequest.getRegion();
                    int x = region.getX(); // all Region fields already guaranteed positive if region!="full"
                    int y = region.getY();
                    int rh = region.getHeight();
                    int rw = region.getWidth();
                    final float rotation = imageRequest.getRotation();
                    int level = -1; // no level *yet*

                    if (x > hwl[1] || y > hwl[0]) {
                        aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "region x/y coords not within image bounds");
                        return;
                    }
                    // canonicalize region: if it is not "full" but could be, make it so
                    if (x==0 && y==0 && rw==hwl[1] && rh==hwl[0]) {
                        try {
                            region = new Region("full");
                        } catch (IIIFException e) { /**/ }
                    }

                    boolean requireOsdStyle = true;
                    boolean requireLevels = true;
                    boolean allowLowLevels = true;

                    // if configured, don't allow requests that aren't expected when using OpenSeaDragon
                    // Ensures that no tiles are generated (and cached forever!) with odd settings we didn't intend to serve up.
                    if (requireOsdStyle) {
                        if (sw != -1 && sh != -1) { // avoid altered aspect ratio.
                            aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "may not specify both scaled dimensions");
                        } else if (region.usesPercents()) { // percents use float math and make level calculations imprecise.
                            aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Region may not use percent");
                        } else if (rotation != 0f) { // OSD rotates the HTML canvas instead
                            aResponse.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, "rotation must be 0");
                        }
                    }

                    // We bothered to encode our JP2s with these nifty high-quality preset levels. Let's use them!
                    // Even though IIIF protocol only speaks regions, good clients request them at standard power-of-two scales
                    // and boundaries that can be translated into levels.
                    if (requireLevels) {

                        // this requires that the scaled output tile size be standard.
                        if (sw > TILE_SIZE || sh > TILE_SIZE) {
                            aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "max tile size is "+TILE_SIZE);
                            return;
                        }

                        // Even if region is "full", I still need these values for error checking and level calculation
                        if (region.isFullSize()) {
                            x = 0;
                            y = 0;
                            rw = hwl[1]; // image width
                            rh = hwl[0]; // image height
                        }

                        // Find the side length of the region in the image being requested.
                        int rs = 0; // region square side length (if edges of image didn't interfere)
                        int l = 0; // sqrt(rs), which works like a psuedo-level. We convert to a real Djatoka "level" at the end.

                        if (rw < hwl[1]-x) { // if region width isn't against the edge, it is the full square width
                            rs=rw;
                            l = log2(rs);
                        } else if (rh < hwl[0]-y) {  // if region height isn't against the edge, it is the full square height
                            rs=rh;
                            l = log2(rs);
                        } else if (sw > 0 && sw < TILE_SIZE) { // if scale width is less than TILE_SIZE, can extract rs from its value
                            rs = (int)(TILE_SIZE*(hwl[1]-x)/sw); // sw = ceil[ TILE_SIZE * (width-x) / rs ]  => rs = floor[ TILE_SIZE * (width-x) / sw ]
                            l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                            rs = 1<<l; // rs = 2^l
                        } else if (sh > 0 && sh < TILE_SIZE) { // if scale height is less than TILE_SIZE, can extract rs from its value
                            rs = (int)(TILE_SIZE*(hwl[0]-y)/sh); // sh = ceil[ TILE_SIZE * (height-y) / rs ]  => rs = floor[ TILE_SIZE * (height-y) / sh ]
                            l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                            rs = 1<<l; // rs = 2^l
                        } else { // no exact boundary--just use the first one bigger than will fit in given source region
                            final int rbig = Math.max(rw, rh);
                            l = log2(rbig) + (isExactPowerOf2(rbig)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                            rs = 1<<l; // rs = 2^l
                        }

                        // At this point, we have rs = 2^l.
                        // In Djatoka-world, rs = 256 * 2^(maxImageLevels -level) == 2^(maxImageLevels -level +log2(TILESIZE)). So solve for "level".
                        level = hwl[2] + TILE_LOG2 - l;
                        if (LOGGER.isDebugEnabled()) {
                            LOGGER.debug("Level calculated: rs="+rs+", l="+l+", level="+level);
                        }

                        // Sometimes even level 1 isn't zoomed out enough for OSD. It sometimes sends requests corresponding to
                        // correct power-of-two region and scale for levels that would be <= 0. For example, thumbnail in navigator window.
                        if (level < 1 && allowLowLevels) {
                            level = -1; // just do a standard level-less Region request instead, as long as the other conditions still hold.
                        }

                        // calculate what both scale dimensions should be, even if they are given as -1 for default.
                        final int explicitSh = Math.min(Math.round((float)(TILE_SIZE*(hwl[0]-y))/(float)rs),TILE_SIZE);
                        final int explicitSw = Math.min(Math.round((float)(TILE_SIZE*(hwl[1]-x))/(float)rs),TILE_SIZE);

                        // Validate that the request used standard power-if-two region and scale, so our level calculations were valid.
                        // Ensures that no tiles are generated (and cached forever!) at odd dimensions that we didn't intend to serve up.
                        String errorMessage = null;
                        int errorHttpCode = HttpServletResponse.SC_BAD_REQUEST; /// default if there is an error, unless changed
                        if (level > hwl[2]) {
                            errorMessage = "scale level "+level+" requested that is deeper than this image's max of "+hwl[2];
                        } else if (x % rs != 0 || y % rs != 0) {
                            errorMessage = "region x and y coords "+x+","+y+" must fall evenly on boundary of "+rs+" when level is"+level;
                        } else if (rh != Math.min(hwl[0]-y, rs)) {
                            errorMessage = "region height "+rh+" should be "+Math.min(hwl[0]-y, rs)+" when region size is "+rs
                                           +" and bottom edge is "+Integer.toString(hwl[0]-y)+" away";
                        } else if (rw != Math.min(hwl[1]-x, rs)) {
                            errorMessage = "region width "+rw+" should be "+Math.min(hwl[1]-x, rs)+" when region size is "+rs
                                           +" and right edge is "+Integer.toString(hwl[1]-x)+" away";
                        } else if (sh != -1 && sh != explicitSh) {
                            final float raw = (float)(TILE_SIZE*(hwl[0]-y))/(float)rs;
                            errorMessage = "scaled height "+sh+" should be "+explicitSh+" when right edge is "+df.format(raw)
                                           +" (~"+Math.round(raw)+" away after scaling";
                        } else if (sw != -1 && sw != explicitSw) {
                            final float raw = (float)(TILE_SIZE*(hwl[1]-x))/(float)rs;
                            errorMessage = "scaled width "+sw+" should be "+explicitSw+" when bottom edge is "+df.format(raw)
                                           +" (~"+Math.round(raw)+" away after scaling";
                        }
                        if (errorMessage != null) {
                            LOGGER.debug(errorMessage);
                            aResponse.sendError(errorHttpCode, errorMessage);
                            return;
                        }

                        // make scale dimensions explicit -- it's required when using level (and doesn't hurt when not)
                        scale.setExplicit(explicitSw, explicitSh);
                    }

                    // All good! Serve the image tile, ideally from cache
                    checkImageCache(id, level, region, scale, rotation, aRequest, aResponse);
                } else {
                    aResponse.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, "unrecognized IIIF message type");
                }
            }
        }
    }

    /**
     * Quick function to take log base 2 of an integer.
     * @param n int to take log2 of
     * @return log2 of the int.
     */
    private static int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    /**
     * Quick function to determine whether an int is an exact power of 2
     * @param n number to check
     * @return whether n is a power of 2
     */
    private static boolean isExactPowerOf2(int n) {
        return (n & (n-1)) == 0;
    }

    @Override
    public void init() throws ServletException {
        final InputStream is = getClass().getResourceAsStream("/" + PROPERTIES_FILE);

        if (is != null) {
            final Properties props = new Properties();
            try {
                props.loadFromXML(is);
            } catch (final IOException details) {
                if (LOGGER.isWarnEnabled()) {
                    LOGGER.warn("Unable to load properties file: {}", details.getMessage());
                }
            } finally {
                IOUtils.closeQuietly(is);
            }

            String cacheDir;
            if (props.containsKey(VIEW_CACHE_DIR)) {
                cacheDir = props.getProperty(VIEW_CACHE_DIR);
            } else {
                // If we couldn't get cache from config, fall back to tmpdir
                cacheDir = System.getProperty("java.io.tmpdir");
            }
            try {
                tileCache = new PairtreeRoot(cacheDir);
            } catch (IOException details) {
                // properly configured cache is mandatory
                LOGGER.error("Unable to load tile cache directory: {}", details.getMessage());
                throw new ServletException(details.getMessage());
            }

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Cache directory set to {}", cacheDir);
            }

            if (props.containsKey(INTERNAL_SERVER)) {
                internalServer = props.getProperty(INTERNAL_SERVER);
            }
        }

        // get the base URL that this whole webapp is server at (relative to server root)
        contextPath = getServletContext().getContextPath();
        LOGGER.debug("IIIF servlet using context path of {}", contextPath);

        // get the (first) URL that the servlet named "resolver" (in web.xml) is served at, relative to contextPath
        try {
            resolverPath = getServletContext().getServletRegistration("resolver").getMappings().iterator().next();
        } catch (UnsupportedOperationException e) {
            LOGGER.error("Unable to get servlet registration for 'resolver': {}", e.getMessage());
        } catch (NoSuchElementException e) {
            LOGGER.error("No registrations found for servlet 'resolver': {}", e.getMessage());
        }
        if (resolverPath == null) {
            // didn't work? Maybe we can fake something.
            resolverPath = "/resolver";
        }
        LOGGER.debug("IIIF servlet using resolver URL of {}", resolverPath);

        // init lookup LRU caches for oft-repeated calculations
        recentHWL = Collections.synchronizedMap(new LruCache<String, int[]>(RECENT_HWL_SIZE));
        recentTiles = Collections.synchronizedMap(new LruCache<String, String>(RECENT_TILES_SIZE));
    }

    /* this is incorrect for 2 reasons:
     * 1) HEAD should return the exact same headers as GET, per HTTP spec.
     * 2) This returns dims of entire full res image, no matter what piece is requested.
     *    In fact, why does it even return dims? I don't see it in IIIF spec or anything.
     * Fortunately, this method is never called in practice using OpenSeaDragon.
     * For reference, the real GET returns
     *  - Cache-Control (on images only [not metadata], if cached already in PairTree tile cache)
     *  - Content-Type (image/jpeg or text/json, set by IIIFServletFilter)
     *  - Content-Length
    @Override
    protected void doHead(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws ServletException, IOException {
        Logger.debug("IIIF servlet: got HEAD on "+aRequest.getRequestURI());
        try {
            final int[] dimensions = getHeightWidthAndLevels(aRequest, aResponse);

            // TODO: add a content length header too
            if (!aResponse.isCommitted()) {
                aResponse.addIntHeader("X-Image-Height", dimensions[0]);
                aResponse.addIntHeader("X-Image-Width", dimensions[1]);

                aResponse.setStatus(HttpServletResponse.SC_OK);
            }
        } catch (final FileNotFoundException details) {
            aResponse.sendError(HttpServletResponse.SC_NOT_FOUND);
        }
    }
    */

    @Override
    protected long getLastModified(final HttpServletRequest aRequest) {
        // TODO: really implement this using our cached files?
        return super.getLastModified(aRequest);
    }

    private int[] getHeightWidthAndLevels(final String id, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {

        if (recentHWL.containsKey(id)) {
            return recentHWL.get(id);
        }

        int width = 0, height = 0, levels = 0;

        OutputStream outStream = null;
        InputStream inStream = null;

        try {
            final PairtreeObject cacheObject = tileCache.getObject(id);
            final String filename = PairtreeUtils.encodeID(id);
            final File xmlFile = new File(cacheObject, filename + ".xml");

            if (xmlFile.exists() && xmlFile.length() > 0) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Reading XML metadata file: " + xmlFile.getAbsolutePath());
                }

                final Document xml = new Builder().build(xmlFile);
                final Element root = xml.getRootElement();
                final Element sElement = root.getFirstChildElement("Size");
                final String wString = sElement.getAttributeValue("Width");
                final String hString = sElement.getAttributeValue("Height");
                final Element lElement = root.getFirstChildElement("Levels");

                width = wString.equals("") ? 0 : Integer.parseInt(wString);
                height = hString.equals("") ? 0 : Integer.parseInt(hString);

                if (lElement != null) {
                    try {
                        levels = Integer.parseInt(lElement.getValue());
                    } catch (final NumberFormatException details) {
                        if (LOGGER.isErrorEnabled()) {
                            LOGGER.error("{} doesn't look like an integer level", lElement.getValue());
                        }

                        levels = 0;
                    }
                }

                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Returning width/height/levels: {}/{}/{}", width, height, levels);
                }
            } else {
                //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles

                final ServletContext context = getServletContext();
                inStream = context.getResource(XML_TEMPLATE).openStream();

                if (xmlFile.exists()) {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("XML metadata file exists: {}", xmlFile);
                    }

                    if (!xmlFile.delete() && LOGGER.isWarnEnabled()) {
                        LOGGER.warn("File not deleted: {}", xmlFile);
                    }
                }

                outStream = new FileOutputStream(xmlFile);

                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Creating new xml metadata file: " + xmlFile.getAbsolutePath());
                }

                final Document xml = new Builder().build(inStream);
                final Serializer serializer = new Serializer(outStream);
                final String safeID = URLEncode.pathSafetyEncode(id);

                try {
                    String server;
                    if (internalServer != null) {
                        // refer to this server at a pre-configured internal URL, e.g. http://localhost:8080
                        server = internalServer;
                    } else {
                        // refer to this server at the same publicly addressable name the user just did
                        server = getServer(aRequest);
                    }
                    // construct URL with context path because we'll be dispatching it externally to this webapp.
                    final URL url = new URL(server + contextPath
                        + resolverPath + StringUtils.format(RESOLVE_METADATA_QUERY, safeID));

                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Querying image metadata: {}", url);
                    }

                    // issue JSON http request to myself and parse the output as JSON.
                    // Ideally, I could just call the code directly, but the config and init setup for the
                    //   Djatoka code isn't quite worth messing with.
                    final JsonNode json = MAPPER.readTree(url.openStream());

                    // Pull out relevant info from our metadata service
                    width = json.get("width").asInt();
                    height = json.get("height").asInt();
                    levels = json.get("levels").asInt();

                    final Element root = xml.getRootElement();
                    final Element sElement = root.getFirstChildElement("Size");
                    final Attribute wAttribute = sElement.getAttribute("Width");
                    final Attribute hAttribute = sElement.getAttribute("Height");
                    final Element lElement = root.getFirstChildElement("Levels");

                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Width: {}; Height: {}; Level: {}", width, height, levels);
                    }

                    // Save it in our xml file for easier access next time
                    wAttribute.setValue(Integer.toString(width));
                    hAttribute.setValue(Integer.toString(height));
                    lElement.appendChild(Integer.toString(levels));

                    serializer.write(xml);
                    serializer.flush();
                } catch (final IIOException details) {
                    if (details.getCause().getClass().getSimpleName().equals("FileNotFoundException")) {
                        throw new FileNotFoundException(id + " not found");
                    } else {
                        if (LOGGER.isErrorEnabled()) {
                            LOGGER.error("[{}] " + details.getMessage(), id, details);
                        }

                        throw details;
                    }
                }
            }
        } catch (final ParsingException details) {
            aResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, details.getMessage());
        } finally {
            IOUtils.closeQuietly(outStream);
            IOUtils.closeQuietly(inStream);
        }

        int[] result = new int[] { height, width, levels };
        recentHWL.put(id, result);
        return result;
    }

    private void checkImageCache(final String aID, final int aLevel, final Region aRegion, final Size aScale,
            final float aRotation, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {
        final PairtreeObject cacheObject = tileCache.getObject(aID);
        final String fileName = CacheUtils.getFileName(aLevel, aRegion, aScale, aRotation);
        final File imageFile = new File(cacheObject, fileName);

        if (imageFile.exists()) {
            final ServletOutputStream outStream = aResponse.getOutputStream();

            aResponse.setHeader("Content-Length", "" + imageFile.length());
            aResponse.setHeader("Cache-Control", "public, max-age=4838400");
            aResponse.setContentType("image/jpg");

            IOUtils.copyStream(imageFile, outStream);
            IOUtils.closeQuietly(outStream);

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} served from Pairtree cache", imageFile);
            }
        } else {
            //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} not found in cache", imageFile);
            }

            serveNewImage(aID, aLevel, aRegion, aScale, aRotation, aRequest, aResponse);
            cacheNewImage(aRequest, aID + "_" + fileName, imageFile);
        }
    }

    private void serveNewImage(final String aID, final int aLevel, final Region aRegion, final Size aScale,
            final float aRotation, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {
        final String safeID = URLEncode.pathSafetyEncode(aID);
        RequestDispatcher dispatcher;
        String[] values;
        String url;

        // Cast floats as integers because that's what djatoka expects
        // Construct URLs without contextPath because we'll be dispatching them *within* this webapp.
        if (aLevel > 0) {
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, String.valueOf(aLevel), Integer.toString((int) aRotation),
                    aRegion.toDjatokaString(aLevel, aScale) };
            url = resolverPath +StringUtils.format(RESOLVE_IMAGE_QUERY, values);
        } else {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Image requested with no level specified: id={} region={} scale={}", aID, aRegion, aScale);
            }
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, aRegion.toDjatokaString(aLevel, aScale), aScale.toDjatokaString(),
                    Integer.toString((int) aRotation) };
            url = resolverPath +StringUtils.format(RESOLVE_REGION_QUERY, values);
        }

        // Right now we just let the OpenURL interface do the work
        dispatcher = aRequest.getRequestDispatcher(url);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Image requested: {} - {}", aID, url);
        }

        dispatcher.forward(aRequest, aResponse);
    }

    /**
     * For an image that was just served by the OpenURL/Djatoka system, move its file from their cache to ours.
     * @param aRequest the incoming image request that Djatoka just fulfilled
     * @param aKey the image ID + underscore + and the combined display parameters, which match what Djatoka just served.
     * @param aDestFile the destination file in the tile cache PairTree to which to move the served image tile.
     */
    private void cacheNewImage(final HttpServletRequest aRequest, final String aKey, final File aDestFile) {
        final HttpSession session = aRequest.getSession();
        // path to temp file that the djatoka code saved in its temp cache (not the freelib tile cache!)
        final String fileName = (String) session.getAttribute(aKey);

        if (fileName != null) {
            // name by which to reference the cached file when talking to OpenURL code
            final String cacheName = (String) session.getAttribute(fileName);
            final File cachedFile = new File(fileName);

            // This moves the newly created file from the adore-djatoka cache
            // to the freelib-djatoka tile cache (which is pure-FS/Pairtree-based)
            if (cachedFile.exists() && aDestFile != null) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Renaming cache file from {} to {}", cachedFile, aDestFile);
                }

                if (!cachedFile.renameTo(aDestFile) && LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Unable to move cache file: {}", cachedFile);
                } else {
                    // This is the temp file cache used by the OpenURL layer
                    if (!OpenURLJP2KService.removeFromTileCache(cacheName) && LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Unable to remove OpenURL cache file link: {}", fileName);
                    } else {
                        session.removeAttribute(aKey);
                        session.removeAttribute(fileName);
                    }
                }
            } else if (LOGGER.isWarnEnabled() && !cachedFile.exists()) {
                LOGGER.warn("Session had a cache file ({}), but it didn't exist", cachedFile.getAbsoluteFile());
            } else if (LOGGER.isWarnEnabled()) {
                LOGGER.warn("Location for destination cache file was null");
            }
        } else if (LOGGER.isWarnEnabled()) {
            LOGGER.warn("Couldn't cache ({} = {}); session lacked new image information", aKey, aDestFile
                    .getAbsolutePath());
            Enumeration<String> fu = session.getAttributeNames();
            /* while (fu.hasMoreElements()) {
                String name = fu.nextElement();
                LOGGER.warn("  --- session has attribute "+name+" = "+session.getAttribute(name));
            }*/
        }
    }

    /**
     * Returns a URL to the root of the server that a request was sent to
     * @param aRequest incoming request
     * @return externally visible address of the server, with explicit port number
     */
    private static String getServer(final HttpServletRequest aRequest) {
        final StringBuilder server = new StringBuilder();
        server.append(aRequest.getScheme()).append("://");
        server.append(aRequest.getServerName()).append(":");
        server.append(aRequest.getServerPort());
        return server.toString();
    }

    private class LruCache<K,V> extends LinkedHashMap<K,V> {
        private final int maxEntries;
        public LruCache(final int maxEntries) {
            super(maxEntries + 1,0.75f, true);
            this.maxEntries = maxEntries;
        }
        @Override
        protected boolean removeEldestEntry(final Map.Entry<K,V> eldest) {
            return super.size() > maxEntries;
        }
    }
}
