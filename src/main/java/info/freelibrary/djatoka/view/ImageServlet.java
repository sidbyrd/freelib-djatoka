
package info.freelibrary.djatoka.view;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import gov.lanl.adore.djatoka.openurl.OpenURLJP2KService;
import info.freelibrary.djatoka.Constants;
import info.freelibrary.djatoka.iiif.*;
import info.freelibrary.djatoka.util.CacheUtils;
import info.freelibrary.djatoka.util.URLEncode;
import info.freelibrary.util.*;
import nu.xom.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.IIOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.*;

public class ImageServlet extends HttpServlet implements Constants {

    /**
     * The <code>ImageServlet</code>'s <code>serialVersionUID</code>.
     */
    private static final long serialVersionUID = -4142816720756238591L;

    private static final Logger LOGGER = LoggerFactory.getLogger(ImageServlet.class);

    private static final ObjectMapper MAPPER = new ObjectMapper();

    private static final String RESOLVE_METADATA_QUERY =
            "?url_ver=Z39.88-2004&rft_id={}&svc_id=info:lanl-repo/svc/getMetadata";

    private static final String RESOLVE_IMAGE_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.level={}&svc.rotate={}&svc.region={}";

    private static final String RESOLVE_REGION_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.region={}&svc.scale={}&svc.rotate={}";

    private static final String XML_TEMPLATE = "/WEB-INF/metadata.xml";

    /** Max dimension of generated tiles. I can't believe this wasn't already a constant anywhere! */
    private static final int TILE_SIZE = 256;
    private static final int TILE_LOG2 = log2(TILE_SIZE);

    /** PairTree tile cache, where we move tiles generated by Djatoka from its temp cache dir */
    private static PairtreeRoot tileCache = null;

    /** a locally accessible URL to the root of the server this webapp is running on
     * optional: leave null to just use the same URL that externally connecting clients use.
     * Useful if e.g. externally visible on https://server.com, but internally also at http://localhost:8080 */
    private static String internalServer = null;
    /** path this whole webapp is at, relative to server root */
    private static String contextPath = null;
    /** path the resolver servlet is at, relative to contextPath */
    private static String resolverPath = null;

    /** recently accessed Height, Width, and Level lookups, keyed by identifier */
    private static Map<String, int[]> recentHWL = null;
    private static final int HWL_CACHE_SIZE = 500;

    private static final DecimalFormat df = new DecimalFormat("######.00000");

    @Override
    protected void doGet(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws ServletException, IOException {
        final IIIFRequest iiif = (IIIFRequest) aRequest.getAttribute(IIIFRequest.KEY);
	    if (iiif == null) {
		    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "IIIF format required");
	    }

	    String id = null;
	    try {
	        id = iiif.getIdentifier();
	    } catch (NullPointerException e) { /**/ }
	    if (id==null) {
		    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "identifier required");
	    }

        final int[] hwl = getHeightWidthAndLevels(id, aRequest, aResponse);

	    if (iiif instanceof InfoRequest) {
            try {
                final ImageInfo info = new ImageInfo(id, hwl[0], hwl[1], hwl[2]);
                final ServletOutputStream outStream = aResponse.getOutputStream();

                if (iiif.getExtension().equals("xml")) {
                    info.toStream(outStream);
                } else {
                    final String server = getServer(aRequest); // needs to be the externally-accessible address

                    // per IIIF spec, the prefix includes the contextPath already.
                    final String prefix = iiif.getServicePrefix();

                    info.addFormat("jpg"); // FIXME: Configurable options

                    outStream.print(info.toJSON(server, prefix));
                }

                outStream.close();
            } catch (final FileNotFoundException details) {
                aResponse.sendError(HttpServletResponse.SC_NOT_FOUND, id + " not found");
            }
        } else if (iiif instanceof ImageRequest) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Request is handled via the IIIFRequest shim");
            }

            final ImageRequest imageRequest = (ImageRequest) iiif;
            final Size scale = imageRequest.getSize();
            final int sh = scale.getHeight(); // #osd-psychic is always -1
            final int sw = scale.getWidth();
            Region region = imageRequest.getRegion();
            int x = region.getX(); // all Region fields already guaranteed positive if region!="full"
            int y = region.getY();
            int rh = region.getHeight();
            int rw = region.getWidth();
            final float rotation = imageRequest.getRotation();

            // validate that request is allowed
            // #osd-psychic means not an IIIF restriction, but I know OpenSeaDragon should never do that with the config I'm using.
            if (rotation != 0f) { // #osd-psychic OSD rotates on HTML canvas instead
                aResponse.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, "rotation must be 0");
            } else if (sw > TILE_SIZE || sh > TILE_SIZE) {
                aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "max tile size is "+TILE_SIZE);
            } else if (sw != -1 && sh != -1) { // #osd-psychic avoid altered aspect ratio. Already guaranteed not *both* -1.
                aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "may not specify both scaled dimensions");
            } else if (region.usesPercents()) { // #osd-psychic percents use float math and make level calculations imprecise.
                aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Region may not use percent");
            } else {
                if (region.isFullSize()) { // I still need these values for error checking and level calculation
                    x = 0;
                    y = 0;
                    rw = hwl[1]; // image width
                    rh = hwl[0]; // image height
                } else if (x==0 && y==0 && rw==hwl[1] && rh==hwl[0]) { // convert region that covers the entire image to "full"
                    try {
                        region = new Region("full");
                    } catch (IIIFException e) { /**/ }
                }
                if (x > hwl[1] || y > hwl[0]) {
                    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Region x/y coords not within image bounds");
                }

                // We bothered to encode our JP2s with these nifty high-quality preset levels. Let's use them!
                // Even though IIIF only specifies in regions, a good client will request regions that match the way the levels were made.

                int rs = 0; // compute the region square side length at that level (if not clipped in either direction because it goes past an edge)
                int l = 0; // sqrt(rs), which works like a psuedo-level. We convert to a real Djatoka "level" at the end.

                if (rw < hwl[1]-x) { // if region width isn't against the edge, it is the full square width
                    rs=rw;
                    l = log2(rs);
                } else if (rh < hwl[0]-y) {  // if region height isn't against the edge, it is the full square height
                    rs=rh;
                    l = log2(rs);
                } else if (sw > 0 && sw < TILE_SIZE) { // if scale width is less than TILE_SIZE, can extract rs from its value
                    rs = (int)(TILE_SIZE*(hwl[1]-x)/sw); // sw = ceil[ TILE_SIZE * (width-x) / rs ]  => rs = floor[ TILE_SIZE * (width-x) / sw ]
                    l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                    rs = 1<<l; // rs = 2^l
                } else if (sh > 0 && sh < TILE_SIZE) { // if scale height is less than TILE_SIZE, can extract rs from its value
                    rs = (int)(TILE_SIZE*(hwl[0]-y)/sh); // sh = ceil[ TILE_SIZE * (height-y) / rs ]  => rs = floor[ TILE_SIZE * (height-y) / sh ]
                    l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                    rs = 1<<l; // rs = 2^l
                } else { // no exact boundary--just use the first one bigger than will fit in given source region
                    final int rbig = Math.max(rw, rh);
                    l = log2(rbig) + (isExactPowerOf2(rbig)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
                    rs = 1<<l; // rs = 2^l
                }

                // At this point, we have rs = 2^l.
                // In Djatoka-world, rs = 256 * 2^(maxImageLevels -level) == 2^(maxImageLevels -level +log2(TILESIZE)). So solve for "level".
                int level = hwl[2] + TILE_LOG2 - l;
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Level calculated: rs="+rs+", l="+l+", level="+level);
                }

                // Sometimes OSD sends a request corresponding to a more zoomed-out level than the top one.
                // For example, it may do this for the navigator window.
                if (level < 1) {
                    level = 0; // just do a standard level-less Region request instead, as long as the other conditions still hold.
                }

                // calculate what both scale dimensions should be, even if they are given as -1 for default.
                final int realSh = Math.min(Math.round((float)(TILE_SIZE*(hwl[0]-y))/(float)rs),TILE_SIZE);
                final int realSw = Math.min(Math.round((float)(TILE_SIZE*(hwl[1]-x))/(float)rs),TILE_SIZE);

                // Finish validating that the request is allowed. All these are #osd-psychic. Together, they have the effect of ensuring
                // no tiles are generated (and cached forever!) that we didn't intend to serve up.
                if (level > hwl[2]) { // #osd-psychic
                    LOGGER.debug("Scale level requested that is not in the range for this image: level="+level+", min=1, max="+hwl[2]);
                    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Scale level "+level+" not in range (1,"+hwl[2]+") for image");
                } else if (x % rs != 0 || y % rs != 0) { // #osd-psychic
                    LOGGER.debug("Region x or y not evenly divisible by region size at this level: x="+x+", y="+y+", rs="+rs+", level="+level);
                    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Region x and y coords "+x+","+y+" must fall on scale level boundary");
                } else if (rh != Math.min(hwl[0]-y, rs)) { // #osd-psychic
                    LOGGER.debug("Region height not right: rh="+rh+", H-y="+Integer.toString(hwl[0]-y)+", rs="+rs);
                    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Region height "+rh+" doesn't jibe. "
                            +"Square region would be "+rs+", available height is "+Integer.toString(hwl[0]-y));
                } else if (rw != Math.min(hwl[1]-x, rs)) { // #osd-psychic
                    LOGGER.debug("Region width not right: rw="+rw+", W-x="+Integer.toString(hwl[1] - x)+", rs="+rs);
                    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Region width "+rw+" doesn't jibe. "
                            +"Square region would be "+rs+", available width is "+Integer.toString(hwl[1] - x));
                } else if (sh != -1 && sh != realSh) { // #osd-psychic
                    float raw = (float)(TILE_SIZE*(hwl[0]-y))/(float)rs;
                    LOGGER.debug("Scale height not right: sh="+sw+", available height scales to="+df.format(raw)+"=~"+Math.round(raw));
                    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Scale height "+sh+" doesn't jibe. "
                            +"Square tile size would be "+TILE_SIZE+", available height scales to "+df.format(raw)+"=~"+Math.round(raw));
                } else if (sw != -1 && sw != realSw) { // #osd-psychic
                    float raw = (float)(TILE_SIZE*(hwl[1]-x))/(float)rs;
                    LOGGER.debug("Scale width not right: sw="+sw+", available width scales to="+df.format(raw)+"=~"+Math.round(raw));
                    aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Scale width "+sw+" doesn't jibe. "
                            +"Square tile size would be "+TILE_SIZE+", available width scales to "+df.format(raw)+"=~"+Math.round(raw));
                } else {

                    // make scale dimensions explicit -- it's required when using level, and doesn't hurt if not.
                    scale.setExplicit(realSw, realSh);

                    // All good! Serve the image tile, ideally from cache
                    checkImageCache(id, level, region, scale, rotation, aRequest, aResponse);
                }
            }
        } else {
		    aResponse.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, "unrecognized IIIF message type");
	    }
    }

    /**
     * Quick function to take log base 2 of an integer.
     * @param n int to take log2 of
     * @return log2 of the int.
     */
    private static int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    /**
     * Quick function to determine whether an int is an exact power of 2
     * @param n number to check
     * @return whether n is a power of 2
     */
    private static boolean isExactPowerOf2(int n) {
        return (n & (n-1)) == 0;
    }

    @Override
    public void init() throws ServletException {
        final InputStream is = getClass().getResourceAsStream("/" + PROPERTIES_FILE);

        if (is != null) {
            final Properties props = new Properties();
            try {
                props.loadFromXML(is);
            } catch (final IOException details) {
                if (LOGGER.isWarnEnabled()) {
                    LOGGER.warn("Unable to load properties file: {}", details.getMessage());
                }
            } finally {
                IOUtils.closeQuietly(is);
            }

            String cacheDir;
            if (props.containsKey(VIEW_CACHE_DIR)) {
                cacheDir = props.getProperty(VIEW_CACHE_DIR);
            } else {
                // If we couldn't get cache from config, fall back to tmpdir
                cacheDir = System.getProperty("java.io.tmpdir");
            }
            try {
                tileCache = new PairtreeRoot(cacheDir);
            } catch (IOException details) {
                LOGGER.error("Unable to load tile cache directory: {}", details.getMessage());
                throw new ServletException(details.getMessage());
            }

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Cache directory set to {}", cacheDir);
            }

            if (props.containsKey(INTERNAL_SERVER)) {
                internalServer = props.getProperty(INTERNAL_SERVER);
            }
        }

        // get the base URL that this whole webapp is server at (relative to server root)
        contextPath = getServletContext().getContextPath();
        LOGGER.debug("IIIF servlet using context path of {}", contextPath);

        // get the (first) URL that the servlet named "resolver" (in web.xml) is served at, relative to contextPath
        try {
            resolverPath = getServletContext().getServletRegistration("resolver").getMappings().iterator().next();
        } catch (UnsupportedOperationException e) {
            LOGGER.error("Unable to get servlet registration for 'resolver': {}", e.getMessage());
        } catch (NoSuchElementException e) {
            LOGGER.error("No registrations found for servlet 'resolver': {}", e.getMessage());
        }
        if (resolverPath == null) {
            // didn't work? Shouldn't fail here, so just fake something.
            resolverPath = "/resolver";
        }
        LOGGER.debug("IIIF servlet using resolver URL of {}", resolverPath);

        // init cache with 3rd LinkedHashMap param true to keep the list side in access/insert order
        recentHWL = Collections.synchronizedMap(new LruCache<String, int[]>(HWL_CACHE_SIZE));
    }

    /* this is incorrect for 2 reasons:
     * 1) HEAD should return the exact same headers as GET, per HTTP spec.
     * 2) This returns dims of entire full res image, no matter what piece is requested.
     *    In fact, why does it even return dims? I don't see it in IIIF spec or anything.
     * Fortunately, this method is never called in practice using OpenSeaDragon.
     * For reference, the real GET returns
     *  - Cache-Control (on images only [not metadata], if cached already in PairTree tile cache)
     *  - Content-Type (image/jpeg or text/json, set by IIIFServletFilter)
     *  - Content-Length
    @Override
    protected void doHead(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws ServletException, IOException {
        Logger.debug("IIIF servlet: got HEAD on "+aRequest.getRequestURI());
        try {
            final int[] dimensions = getHeightWidthAndLevels(aRequest, aResponse);

            // TODO: add a content length header too
            if (!aResponse.isCommitted()) {
                aResponse.addIntHeader("X-Image-Height", dimensions[0]);
                aResponse.addIntHeader("X-Image-Width", dimensions[1]);

                aResponse.setStatus(HttpServletResponse.SC_OK);
            }
        } catch (final FileNotFoundException details) {
            aResponse.sendError(HttpServletResponse.SC_NOT_FOUND);
        }
    }
    */

    @Override
    protected long getLastModified(final HttpServletRequest aRequest) {
        // TODO: really implement this using our cached files?
        return super.getLastModified(aRequest);
    }

    private int[] getHeightWidthAndLevels(final String id, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {

        if (recentHWL.containsKey(id)) {
            return recentHWL.get(id);
        }

        int width = 0, height = 0, levels = 0;

        OutputStream outStream = null;
        InputStream inStream = null;

        try {
            final PairtreeObject cacheObject = tileCache.getObject(id);
            final String filename = PairtreeUtils.encodeID(id);
            final File xmlFile = new File(cacheObject, filename + ".xml");

            if (xmlFile.exists() && xmlFile.length() > 0) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Reading XML metadata file: " + xmlFile.getAbsolutePath());
                }

                final Document xml = new Builder().build(xmlFile);
                final Element root = xml.getRootElement();
                final Element sElement = root.getFirstChildElement("Size");
                final String wString = sElement.getAttributeValue("Width");
                final String hString = sElement.getAttributeValue("Height");
                final Element lElement = root.getFirstChildElement("Levels");

                width = wString.equals("") ? 0 : Integer.parseInt(wString);
                height = hString.equals("") ? 0 : Integer.parseInt(hString);

                if (lElement != null) {
                    try {
                        levels = Integer.parseInt(lElement.getValue());
                    } catch (final NumberFormatException details) {
                        if (LOGGER.isErrorEnabled()) {
                            LOGGER.error("{} doesn't look like an integer level", lElement.getValue());
                        }

                        levels = 0;
                    }
                }

                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Returning width/height/levels: {}/{}/{}", width, height, levels);
                }
            } else {
                //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles

                final ServletContext context = getServletContext();
                inStream = context.getResource(XML_TEMPLATE).openStream();

                if (xmlFile.exists()) {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("XML metadata file exists: {}", xmlFile);
                    }

                    if (!xmlFile.delete() && LOGGER.isWarnEnabled()) {
                        LOGGER.warn("File not deleted: {}", xmlFile);
                    }
                }

                outStream = new FileOutputStream(xmlFile);

                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Creating new xml metadata file: " + xmlFile.getAbsolutePath());
                }

                final Document xml = new Builder().build(inStream);
                final Serializer serializer = new Serializer(outStream);
                final String safeID = URLEncode.pathSafetyEncode(id);

                try {
                    String server;
                    if (internalServer != null) {
                        // refer to this server at a pre-configured internal URL, e.g. http://localhost:8080
                        server = internalServer;
                    } else {
                        // refer to this server at the same publicly addressable name the user just did
                        server = getServer(aRequest);
                    }
                    // construct URL with context path because we'll be dispatching it externally to this webapp.
                    final URL url = new URL(server + contextPath
                        + resolverPath + StringUtils.format(RESOLVE_METADATA_QUERY, safeID));

                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Querying image metadata: {}", url);
                    }

                    // issue JSON http request to myself and parse the output as JSON.
                    // Ideally, I could just call the code directly, but the config and init setup for the
                    //   Djatoka code isn't quite worth messing with.
                    final JsonNode json = MAPPER.readTree(url.openStream());

                    // Pull out relevant info from our metadata service
                    width = json.get("width").asInt();
                    height = json.get("height").asInt();
                    levels = json.get("levels").asInt();

                    final Element root = xml.getRootElement();
                    final Element sElement = root.getFirstChildElement("Size");
                    final Attribute wAttribute = sElement.getAttribute("Width");
                    final Attribute hAttribute = sElement.getAttribute("Height");
                    final Element lElement = root.getFirstChildElement("Levels");

                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Width: {}; Height: {}; Level: {}", width, height, levels);
                    }

                    // Save it in our xml file for easier access next time
                    wAttribute.setValue(Integer.toString(width));
                    hAttribute.setValue(Integer.toString(height));
                    lElement.appendChild(Integer.toString(levels));

                    serializer.write(xml);
                    serializer.flush();
                } catch (final IIOException details) {
                    if (details.getCause().getClass().getSimpleName().equals("FileNotFoundException")) {
                        throw new FileNotFoundException(id + " not found");
                    } else {
                        if (LOGGER.isErrorEnabled()) {
                            LOGGER.error("[{}] " + details.getMessage(), id, details);
                        }

                        throw details;
                    }
                }
            }
        } catch (final ParsingException details) {
            aResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, details.getMessage());
        } finally {
            IOUtils.closeQuietly(outStream);
            IOUtils.closeQuietly(inStream);
        }

        int[] result = new int[] { height, width, levels };
        recentHWL.put(id, result);
        return result;
    }

    private void checkImageCache(final String aID, final int aLevel, final Region aRegion, final Size aScale,
            final float aRotation, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {
        final PairtreeObject cacheObject = tileCache.getObject(aID);
        final String fileName = CacheUtils.getFileName(aLevel, aRegion, aScale, aRotation);
        final File imageFile = new File(cacheObject, fileName);

        if (imageFile.exists()) {
            final ServletOutputStream outStream = aResponse.getOutputStream();

            aResponse.setHeader("Content-Length", "" + imageFile.length());
            aResponse.setHeader("Cache-Control", "public, max-age=4838400");
            aResponse.setContentType("image/jpg");

            IOUtils.copyStream(imageFile, outStream);
            IOUtils.closeQuietly(outStream);

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} served from Pairtree cache", imageFile);
            }
        } else {
            //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} not found in cache", imageFile);
            }

            serveNewImage(aID, aLevel, aRegion, aScale, aRotation, aRequest, aResponse);
            cacheNewImage(aRequest, aID + "_" + fileName, imageFile);
        }
    }

    private void serveNewImage(final String aID, final int aLevel, final Region aRegion, final Size aScale,
            final float aRotation, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException, ServletException {
        final String safeID = URLEncode.pathSafetyEncode(aID);
        RequestDispatcher dispatcher;
        String[] values;
        String url;

        // Cast floats as integers because that's what djatoka expects
        // Construct URLs without contextPath because we'll be dispatching them *within* this webapp.
        if (aLevel > 0) {
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, String.valueOf(aLevel), Integer.toString((int) aRotation),
                    aRegion.toDjatokaString(aLevel, aScale) };
            url = resolverPath +StringUtils.format(RESOLVE_IMAGE_QUERY, values);
        } else {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Image requested with no level specified: id={} region={} scale={}", aID, aRegion, aScale);
            }
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, aRegion.toDjatokaString(aLevel, aScale), aScale.toDjatokaString(),
                    Integer.toString((int) aRotation) };
            url = resolverPath +StringUtils.format(RESOLVE_REGION_QUERY, values);
        }

        // Right now we just let the OpenURL interface do the work
        dispatcher = aRequest.getRequestDispatcher(url);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Image requested: {} - {}", aID, url);
        }

        dispatcher.forward(aRequest, aResponse);
    }

    /**
     * For an image that was just served by the OpenURL/Djatoka system, move its file from their cache to ours.
     * @param aRequest the incoming image request that Djatoka just fulfilled
     * @param aKey the image ID + underscore + and the combined display parameters, which match what Djatoka just served.
     * @param aDestFile the destination file in the tile cache PairTree to which to move the served image tile.
     */
    private void cacheNewImage(final HttpServletRequest aRequest, final String aKey, final File aDestFile) {
        final HttpSession session = aRequest.getSession();
        // path to temp file that the djatoka code saved in its temp cache (not the freelib tile cache!)
        final String fileName = (String) session.getAttribute(aKey);

        if (fileName != null) {
            // name by which to reference the cached file when talking to OpenURL code
            final String cacheName = (String) session.getAttribute(fileName);
            final File cachedFile = new File(fileName);

            // This moves the newly created file from the adore-djatoka cache
            // to the freelib-djatoka tile cache (which is pure-FS/Pairtree-based)
            if (cachedFile.exists() && aDestFile != null) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Renaming cache file from {} to {}", cachedFile, aDestFile);
                }

                if (!cachedFile.renameTo(aDestFile) && LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Unable to move cache file: {}", cachedFile);
                } else {
                    // This is the temp file cache used by the OpenURL layer
                    if (!OpenURLJP2KService.removeFromTileCache(cacheName) && LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Unable to remove OpenURL cache file link: {}", fileName);
                    } else {
                        session.removeAttribute(aKey);
                        session.removeAttribute(fileName);
                    }
                }
            } else if (LOGGER.isWarnEnabled() && !cachedFile.exists()) {
                LOGGER.warn("Session had a cache file ({}), but it didn't exist", cachedFile.getAbsoluteFile());
            } else if (LOGGER.isWarnEnabled()) {
                LOGGER.warn("Location for destination cache file was null");
            }
        } else if (LOGGER.isWarnEnabled()) {
            LOGGER.warn("Couldn't cache ({} = {}); session lacked new image information", aKey, aDestFile
                    .getAbsolutePath());
            Enumeration<String> fu = session.getAttributeNames();
            /* while (fu.hasMoreElements()) {
                String name = fu.nextElement();
                LOGGER.warn("  --- session has attribute "+name+" = "+session.getAttribute(name));
            }*/
        }
    }

    /**
     * Returns a URL to the root of the server that a request was sent to
     * @param aRequest incoming request
     * @return externally visible address of the server, with explicit port number
     */
    private static String getServer(final HttpServletRequest aRequest) {
        final StringBuilder server = new StringBuilder();
        server.append(aRequest.getScheme()).append("://");
        server.append(aRequest.getServerName()).append(":");
        server.append(aRequest.getServerPort());
        return server.toString();
    }

    private class LruCache<K,V> extends LinkedHashMap<K,V> {
        private final int maxEntries;
        public LruCache(final int maxEntries) {
            super(maxEntries + 1,0.75f, true);
            this.maxEntries = maxEntries;
        }
        @Override
        protected boolean removeEldestEntry(final Map.Entry<K,V> eldest) {
            return super.size() > maxEntries;
        }
    }
}
