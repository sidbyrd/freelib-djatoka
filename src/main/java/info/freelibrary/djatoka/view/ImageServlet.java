
package info.freelibrary.djatoka.view;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import gov.lanl.adore.djatoka.openurl.OpenURLJP2KService;
import info.freelibrary.djatoka.Constants;
import info.freelibrary.djatoka.iiif.*;
import info.freelibrary.djatoka.util.CacheUtils;
import info.freelibrary.djatoka.util.URLEncode;
import info.freelibrary.util.*;
import nu.xom.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.*;

public class ImageServlet extends HttpServlet implements Constants {

    /**
     * The <code>ImageServlet</code>'s <code>serialVersionUID</code>.
     */
    private static final long serialVersionUID = -4142816720756238591L;

    private static final Logger LOGGER = LoggerFactory.getLogger(ImageServlet.class);

    private static final ObjectMapper MAPPER = new ObjectMapper();

    private static final String RESOLVE_METADATA_QUERY =
            "?url_ver=Z39.88-2004&rft_id={}&svc_id=info:lanl-repo/svc/getMetadata";

    private static final String RESOLVE_IMAGE_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.level={}&svc.rotate={}&svc.region={}";

    private static final String RESOLVE_REGION_QUERY = "?url_ver=Z39.88-2004&rft_id={}"
            + "&svc_id=info:lanl-repo/svc/getRegion" + "&svc_val_fmt=info:ofi/fmt:kev:mtx:jpeg2000"
            + "&svc.format={}&svc.region={}&svc.scale={}&svc.rotate={}";

    private static final String XML_TEMPLATE = "/WEB-INF/metadata.xml";

    /**
     * IIIFException HTTP error messages
     */
    static final String EM_STYLE_SCALE_NUMERIC = "Scale not numeric";
    static final String EM_STYLE_SCALE_CONSTRAINED = "Scale may not constrain both dimensions";
    static final String EM_STYLE_REGION_NUMERIC = "Region not numeric or \"full\"";
    static final String EM_STYLE_ROTATION_0 = "Rotation not 0";
    static final String EM_STYLE_REGION_MAX_DIMS = "Region dimensions extend beyond image";
    static final String EM_REGION_MAX_COORDS = "Region coordinates do not start within image";
    static final String EM_TILE_MAX = "Scaled size exceeds max tile size";
    static final String EM_LEVEL_MIN = "Implied zoom level is below allowed minimum";
    static final String EM_LEVEL_MAX = "Implied zoom level is above image's maximum";
    static final String EM_REGION_BOUNDARY_DIMS = "Region dimensions do not end on proper boundary";
    static final String EM_REGION_BOUNDARY_COORDS = "Region coordinates do not start on proper boundary";
    static final String EM_REGION_HEIGHT = "Region height doesn't match implied zoom level";
    static final String EM_REGION_WIDTH = "Region width doesn't match implied zoom level";
    static final String EM_SCALED_HEIGHT = "Scaled height doesn't match implied zoom level";
    static final String EM_SCALED_WIDTH = "Scaled width doesn't match implied zoom level";
    static final String EM_CONFIG = "Configuration error";
    static final String EM_RESOLVER_NOT_FOUND = "Identifier not found";
    static final String EM_RESOLVER_DISPATCH = "Couldn't dispatch to resolver";
    static final String EM_IMAGE_FETCH = "Couldn't fetch image tile";
    static final String EM_METADATA_FETCH = "Couldn't fetch image metadata";
    static final String EM_METADATA_XML_READ = "Couldn't read image metadata file";
    static final String EM_METADATA_XML_INVALID = "Invalid image metadata file";
    static final String EM_METADATA_XML_WRITE = "Couldn't write image metadata file";
    static final String EM_TEMPLATE_XML_READ = "Couldn't read metadata template file";
    static final String EM_TEMPLATE_XML_INVALID = "Invalid metadata template file";
    static final String EM_TILECACHE_ACCESS = "Couldn't access tile cache";
    static final String EM_SEND_METADATA = "Couldn't send metadata";
    static final String EM_SEND_IMAGE = "Couldn't send image";

    /**
     * Max dimension of generated tiles.
     * This should really be a config property, but it's already hardcoded in like a million places.
     * Also, I can't even import this const from anywhere else because it doesn't exist. Unbelievable!
     */
    private static final int TILE_SIZE = 256;
    private static final int TILE_LOG2 = log2(TILE_SIZE); // == 8

    /**
     * PairTree tile cache, where we move tiles generated by Djatoka from its temp cache dir
     */
    private PairtreeRoot tileCache = null;

    /**
     * a locally accessible URL to the root of the server this webapp is running on
     * optional: leave null to just use the same URL that externally connecting clients use.
     * Useful if e.g. externally visible on https://server.com, but internally also at http://localhost:8080
     * */
    private String internalServer = null;

    /**
     * Set to return error if served an option or property setting that I have
     * noticed OpenSeaDragon never uses. Can help keep possible accepted parameters finite.
     * */
    private boolean requireOsdStyle = true;

    /**
     * Set to require region and scaling settings to align on power-of-two boundaries corresponding
     * to the zoom level desired (and legal for the requested image). Dispatches djatoka request
     * using the svc.level option for faster and higher quality results, and returns an error to
     * any requests for region+scale that doesn't align properly with zoom levels. Compatible with
     * OpenSeaDragon. Reduces possible space of parameters to something finite (and pre-generate-able).
     */
    private boolean requireLevels = true;

    /**
     * JP2 images has a certain number of zoom settings encoded in them. If requireLevels==true, set
     * this to allow requests for images zoomed farther out than level 1, which is the normal minimum.
     */
    private int minZoomLevel = 1;

    /** path this whole webapp is at, relative to server root */
    private String contextPath = null;

    /** path the resolver servlet is at, relative to contextPath */
    private String resolverPath = null;

    /**
     * Recently accessed Height, Width, and Level lookups, keyed by identifier.
     * Also caches JSON/SML output if a metadata query is performed against the key identifier.
     * May safely be left null if you don't want to use caching here.
     */
    private Map<String, ImageInfo> recentImageInfo = null;
    private static final int RECENT_HWL_SIZE = 500;

    /**
     * Recently accessed tile filenames, keyed by URL
     * value is pair of HTTP status code and filename (or error message if code != SC_OK)
     * Unlike external response caching, this doesn't have to store the entire file contents.
     * May safely be left null if you don't want to use caching here.
     */
    private Map<String, Map.Entry<Integer, String>> recentTiles = null;
    private static final int RECENT_TILES_SIZE = 50000;

    /** for logging */
    private static final DecimalFormat df = new DecimalFormat("######.00000");


    @Override
    public void init() throws ServletException {
        final InputStream is = getClass().getResourceAsStream("/" + PROPERTIES_FILE);
        if (is != null) {
            final Properties props = new Properties();
            try {
                props.loadFromXML(is);
            } catch (final IOException details) {
                if (LOGGER.isWarnEnabled()) {
                    LOGGER.warn("Unable to load properties file: {}", details.getMessage());
                }
            } finally {
                IOUtils.closeQuietly(is);
            }

            // cache dir
            String cacheDir;
            if (props.containsKey(VIEW_CACHE_DIR)) {
                cacheDir = props.getProperty(VIEW_CACHE_DIR);
            } else {
                // If we couldn't get cache from config, fall back to tmpdir
                cacheDir = System.getProperty("java.io.tmpdir");
            }
            try {
                tileCache = new PairtreeRoot(cacheDir);
            } catch (IOException details) {
                // properly configured cache is mandatory
                LOGGER.error("Unable to load tile cache directory: {}", details.getMessage());
                throw new ServletException(details.getMessage());
            }

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Cache directory set to {}", cacheDir);
            }

            // general properties
            if (props.containsKey(INTERNAL_SERVER)) {
                // refer to this server at a pre-configured internal URL, e.g. http://localhost:8080
                internalServer = props.getProperty(INTERNAL_SERVER);
            }

            if (props.containsKey(REQUIRE_OSD_STYLE)) {
                requireOsdStyle = props.getProperty(REQUIRE_OSD_STYLE).equals("true");
            }
            if (props.containsKey(REQUIRE_LEVELS)) {
                requireLevels = props.getProperty(REQUIRE_LEVELS).equals("true");
            }
            if (props.containsKey(REQUIRE_LEVELS_MIN)) {
                try {
                    minZoomLevel = Integer.parseInt(props.getProperty(REQUIRE_LEVELS_MIN));
                } catch (NumberFormatException e) {
                    LOGGER.warn("Property "+REQUIRE_LEVELS_MIN+" was not a number; using "+ minZoomLevel +" instead");
                }
                if (minZoomLevel > 1) {
                    LOGGER.warn("Property "+REQUIRE_LEVELS_MIN+"="+minZoomLevel+" was clipped to a max of 1");
                    minZoomLevel = 1;
                }
            }
        }

        // get the base URL that this whole webapp is at (relative to server root)
        contextPath = getServletContext().getContextPath();
        LOGGER.debug("IIIF servlet using context path of {}", contextPath);

        // get the (first) URL that the servlet named "resolver" (in web.xml) is served at, relative to contextPath
        try {
            resolverPath = getServletContext().getServletRegistration("resolver").getMappings().iterator().next();
        } catch (UnsupportedOperationException e) {
            LOGGER.error("Unable to get servlet registration for 'resolver': {}", e.getMessage());
        } catch (NoSuchElementException e) {
            LOGGER.error("No registrations found for servlet 'resolver': {}", e.getMessage());
        }
        if (resolverPath == null) {
            // didn't work? Maybe we can fake something.
            resolverPath = "/resolver";
        }
        LOGGER.debug("IIIF servlet using resolver URL of {}", resolverPath);

        // init lookup LRU caches for oft-repeated calculations
        recentImageInfo = Collections.synchronizedMap(new LruCache<String, ImageInfo>(RECENT_HWL_SIZE));
        recentTiles = Collections.synchronizedMap(new LruCache<String, Map.Entry<Integer, String>>(RECENT_TILES_SIZE));
    }

    /**
     * Serves from a filename or prepared error message and caches its pair input in recentTiles
     * @param pair key:   HTTP response code
     *             value: if code==200: the file path of a JPG file to serve. Must exist!
     *                    if code!=200: message text to display on error page
     * @param aRequest the request being served
     * @param aResponse the response to serve
     * @throws IOException if serving response
     */
    private void serveAndCache(Map.Entry<Integer, String> pair,
                                      HttpServletRequest aRequest, HttpServletResponse aResponse) throws IOException {
        if (pair.getKey().equals(HttpServletResponse.SC_OK)) {
            try {
                serveJpgFile(pair.getValue(), aResponse);
                if (recentTiles != null) {
                    recentTiles.put(aRequest.getRequestURI(), pair);
                }
            } catch (IIIFException e) {
                LOGGER.warn("couldn't serve file "+pair.getValue()+" : "+e.getMessage());
                aResponse.sendError(e.getHttpCode(), e.getHttpMessage());
                // if serving cached filename failed, remove from cache.
                if (recentTiles != null) {
                    recentTiles.remove(aRequest.getRequestURI());
                }
            }
        } else {
            aResponse.sendError(pair.getKey(), pair.getValue());
            if (recentTiles != null) {
                recentTiles.put(aRequest.getRequestURI(), pair);
            }
        }
    }

    /**
     * Handles both main types of IIIF requests: InfoRequests (for image metadata), and
     * ImageRequest (for tiles of image content).
     * Internally, it validates a bunch of stuff, transforms the request, forwards it
     * to the Djatoka resolver for fulfillment, caches the returned files and metadata,
     * and further caches the filenames (and error responses) so it doesn't have to
     * re-validate and re-transform the requests every time.
     * @param aRequest request for IIIF service
     * @param aResponse our response
     * @throws IOException if cannot send to aResponse. Other errors are written to aResponse
     * as HTTP error pages (and perhaps also logged).
     */
    @Override
    protected void doGet(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IOException {
        if (internalServer == null) {
            // This needs to be *any* valid way to address this server.
            // If the admin cared which, they would have set the INTERNAL_SERVER config property.
            // We only need to set this static variable once, but we don't have the info yet
            //  at config time, so do it now.
            internalServer = getServer(aRequest);
        }

        final IIIFRequest iiif = (IIIFRequest) aRequest.getAttribute(IIIFRequest.KEY);

	    if (iiif == null) {
            aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "IIIF format required");
            return;
	    }
        final String id = iiif.getIdentifier();
        if (id==null) {
            aResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "identifier required");
            return;
        }

        // see if we already have a cached response
        final String uri=aRequest.getRequestURI();
        Map.Entry<Integer, String> response = (recentTiles==null)?null : recentTiles.get(uri);

        if (response != null) {
            // serve the cached file or error again, with lots less mucking about with strings and math
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("serving cached response with code {}",response.getKey());
            }
            serveAndCache(response, aRequest, aResponse);
        } else {
            try {
                if (iiif instanceof InfoRequest) {
                    doInfoRequest((InfoRequest)iiif, aRequest, aResponse);
                } else if (iiif instanceof ImageRequest) {
                    doImageRequest((ImageRequest)iiif, aRequest, aResponse);
                } else {
                    aResponse.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, "unrecognized IIIF message type");
                }
            } catch (IIIFException re) {
                // send any error messages
                serveAndCache(re.getPair(), aRequest, aResponse);
                // log the error if appropriate
                if (LOGGER.isWarnEnabled()) { // == isWarnEnabled() || isDebugEnabled(), since former implies latter.
                    // log as WARN if it's an actual server error, not just "not found" or "bad request" or some other client error
                    final boolean isWarn = re.getHttpCode() >= 500;
                    if (isWarn || LOGGER.isDebugEnabled()) {
                        StringBuilder message = new StringBuilder().append("error ").append(re.getHttpCode())
                                .append(": ").append(re.getMessage());
                        if (re.getCause() != null) {
                            message=message.append(" from ").append(re.getCause());
                        }
                        if (isWarn) {
                            LOGGER.warn(message.toString());
                        } else {
                            LOGGER.debug(message.toString());
                        }
                    }
                }
            }
        }
    }

    /*
     * We cannot generate this efficiently if we want to conform to HTTP spec and
     * have the headers be exactly the same as a real GET request.
     * Fortunately, this method is never called in practice using OpenSeaDragon.
     * */
    @Override
    protected void doHead(final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws ServletException, IOException {
        if (internalServer == null) {
            internalServer = getServer(aRequest);
        }
        super.doHead(aRequest, aResponse);
    }

    @Override
    protected long getLastModified(final HttpServletRequest aRequest) {
        // TODO: really implement this using our cached files?
        return super.getLastModified(aRequest);
    }

    /**
     * Serves an IIIF image info request
     * @param iiif parsed parameters of the request
     * @param aRequest HTTP request being fulfilled
     * @param aResponse HTTP response to serve out on
     * @throws IIIFException if error retrieving or formatting metadata or copying metadata
     */
    protected void doInfoRequest(final InfoRequest iiif, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IIIFException {
        // fetch the metadata that is being requested
        final ImageInfo imageInfo = getImageInfoWithCaching(iiif.getIdentifier());

        // write it to output
        ServletOutputStream outStream = null;
        try {
            outStream = aResponse.getOutputStream();

            if (iiif.getExtension().equals("xml")) {
                imageInfo.toStreamXML(outStream);
            } else {
                final String server = getServer(aRequest); // needs to be the externally-accessible address

                // per IIIF spec, the prefix includes the contextPath already.
                final String prefix = iiif.getServicePrefix();

                imageInfo.addFormat("jpg"); // FIXME: Configurable options

                outStream.print(imageInfo.toJSON(server, prefix));
            }
        } catch (final JsonProcessingException e) {
            // "couldn't make JSON"
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_CONFIG, e);
        } catch (final IOException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_SEND_METADATA, e);
        } finally {
            IOUtils.closeQuietly(outStream);
        }
    }

    /**
     * Serves an IIIF image request
     * @param iiif parsed parameters of the request
     * @param aRequest HTTP request being fulfilled
     * @param aResponse HTTP response to serve out on
     * @throws IIIFException if error retrieving or sending image, or if parameters are invalid
     */
    protected void doImageRequest(final ImageRequest iiif, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IIIFException {
        final String id = iiif.getIdentifier();
        final ImageInfo imageInfo = getImageInfoWithCaching(id); // of source image; already cached if user requested metadata
        final Region region = iiif.getRegion(); // refers to a region within source image, at native resolution
        final Size scale = iiif.getSize(); // refers to the size of tile requested, generated from Region, usually smaller.
        final float rotation = iiif.getRotation();
        final int imageHeight = imageInfo.getHeight();
        final int imageWidth = imageInfo.getWidth();
        int level = -1; // no level yet

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Request is handled via the IIIFRequest shim");
        }

        // validate some obvious basics
        if (region.getX() > imageWidth || region.getY() > imageHeight) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_REGION_MAX_COORDS);
        }
        if (scale.getHeight() > TILE_SIZE || scale.getWidth() > TILE_SIZE) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_TILE_MAX);
        }

        if (requireOsdStyle) {
            // Do this before normalization, because that un-uses certain features that we want to ban beforehand.
            validateOsdStyle(imageInfo, region, scale, rotation);
        }

        // get rid of stuff like percentages and scale==full, and force use of region==full if applicable.
        // Nice anyways, but mandatory before using levels.
        region.normalizeForImageDims(imageWidth, imageHeight);
        scale.normalizeForRegionDims(region.getWidth(), region.getHeight());

        if (requireLevels) {
            level = findLevelFromRegion(imageInfo, region, scale);
        }
        // All good! Serve the image tile, ideally from cache
        String cachedFilename = serveImageWithCaching(id, level, region, scale, rotation, aRequest, aResponse);

        if (recentTiles != null && cachedFilename != null) {
            // cache the served filename
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Adding served filename to recentTiles cache:\n{} -> {}", aRequest.getRequestURI(), cachedFilename);
            }
            recentTiles.put(aRequest.getRequestURI(),
                    new AbstractMap.SimpleImmutableEntry<Integer, String>(HttpServletResponse.SC_OK, cachedFilename));
        }
    }

    /**
     * Checks the given IIIF parameters to make sure they don't use any features or values that
     * OpenSeaDragon is known to never use.
     * @param imageInfo image metadata
     * @param region IIIF region
     * @param scale IIIF scale
     * @param rotation IIIF rotation
     * @throws IIIFException if something was invalid
     */
    private void validateOsdStyle(ImageInfo imageInfo, Region region, Size scale, float rotation) throws IIIFException {
        if (scale.isFullSize() || scale.isPercent()) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_STYLE_SCALE_NUMERIC);
        } else if ((scale.hasWidth() && scale.hasHeight()) || !scale.maintainsAspectRatio()) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_STYLE_SCALE_CONSTRAINED);
        } else if (region.usesPercents()) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_STYLE_REGION_NUMERIC);
        } else if (rotation != 0f) { // OSD rotates the HTML canvas instead
            throw new IIIFException(HttpServletResponse.SC_NOT_IMPLEMENTED, EM_STYLE_ROTATION_0);
        } else if (region.getY()+region.getHeight() > imageInfo.getHeight()
                   || region.getX()+region.getWidth() > imageInfo.getWidth()) {
            throw new IIIFException(HttpServletResponse.SC_NOT_IMPLEMENTED, EM_STYLE_REGION_MAX_DIMS);
        }
    }

    /**
     * Computes the Djatoka zoom level that the given image size, region, and scale correspond to.
     * Validates all settings to make sure they represent valid combinations, like making
     * sure the region x,y coords start on an even multiple of the correct power of two, etc.
     * May modify the scale to make both its dimensions explicit if they weren't already.
     *
     * We bothered to encode our JP2s with these nifty levels. And they decode faster and at higher
     * quality. Let's use them!
     * @param imageInfo the ImageInfo with details about the image in question
     * @param region the region of interest within the source image
     * @param scale the scale to generate the output tile at
     * @return the svc.level to request from Djatoka, or -1 to indicate that a level-based request
     *   would be inappropriate (even though settings were otherwise valid)
     * @throws IIIFException if settings were invalid for using levels
     */
    private int findLevelFromRegion(final ImageInfo imageInfo, final Region region, final Size scale)
            throws IIIFException {
        // Lots of equations, so extract simple local names for our inputs
        final int ih = imageInfo.getHeight();
        final int iw = imageInfo.getWidth();
        final int il = imageInfo.getLevels();

        final int rx = region.getX(); // all Region fields already guaranteed positive if region!="full"
        final int ry = region.getY();
        final int rh = region.getHeight();
        final int rw = region.getWidth();

        final int sh = scale.getHeight(); // with OpenSeaDragon, is always -1.
        final int sw = scale.getWidth(); // if sh is -1, sw is already guaranteed to not be -1 if scale!="full"

        // This is what we're here to find.
        int level;

        // pre-validations that apply when using levels
        if (rw < iw-rx && !isExactPowerOf2(rw)) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_REGION_BOUNDARY_DIMS,
                    "region width "+rw+" not a power of two and not limited by image edge");
        } else if (rh < ih-ry && !isExactPowerOf2(rh)) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_REGION_BOUNDARY_DIMS,
                    "region height "+rh+" not a power of two and not limited by image edge");
        }

        // Find the side length of the region in the image being requested.
        int rs; // region square side length (if edges of image didn't interfere)
        int l; // sqrt(rs), which works like a psuedo-level. We convert to a real Djatoka "level" at the end.

        if (rw < iw-rx) { // if region width isn't against the edge, it is the full square width
            rs=rw;
            l = log2(rs);
        } else if (rh < ih-ry) {  // if region height isn't against the edge, it is the full square height
            rs=rh;
            l = log2(rs);
        } else if (sw > 0 && sw < TILE_SIZE) { // if scale width is less than TILE_SIZE, can extract rs from its value
            rs = TILE_SIZE*(iw-rx)/sw; // sw = ceil[ TILE_SIZE * (iw-rx) / rs ]  => rs = floor[ TILE_SIZE * (iw-rx) / sw ]
            l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
            rs = 1<<l; // rs = 2^l
        } else if (sh > 0 && sh < TILE_SIZE) { // if scale height is less than TILE_SIZE, can extract rs from its value
            rs = TILE_SIZE*(ih-ry)/sh; // sh = ceil[ TILE_SIZE * (ih-ry) / rs ]  => rs = floor[ TILE_SIZE * (ih-ry) / sh ]
            l = log2(rs) + (isExactPowerOf2(rs)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
            rs = 1<<l; // rs = 2^l
        } else { // no exact boundary--just use the first one bigger than will fit in given source region
            final int rbig = Math.max(rw, rh);
            l = log2(rbig) + (isExactPowerOf2(rbig)? 0 : 1); // l = log2(rs), +1 if rs wasn't an even power of 2
            rs = 1<<l; // rs = 2^l
        }

        // At this point, we have rs = 2^l.
        // In Djatoka-world, rs = TILESIZE * 2^(il -level) == 2^(il -level +log2(TILESIZE)). So solve for "level".
        level = il + TILE_LOG2 - l;
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Level calculated: rs="+rs+", l="+l+", level="+level);
        }

        // Zoom levels < 1 are not legal in Djatoka, but they may still be requested for thumbnails or tiny screens.
        if (level < 1) {
            if (level >= minZoomLevel) {
                level = -1; // just do a standard level-less Region request instead, as long as the other conditions still hold.
            } else {
                throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_LEVEL_MIN,
                        "region and scale correspond to zoom level "+level+" below allowed min of "+minZoomLevel);
            }
        }

        // calculate what both scale dimensions should be, even if one was given as -1 for unconstrained.
        final int explicitSh = Math.min(Math.round((float)(TILE_SIZE*(ih-ry))/(float)rs),TILE_SIZE);
        final int explicitSw = Math.min(Math.round((float)(TILE_SIZE*(iw-rx))/(float)rs),TILE_SIZE);

        // Validate that the request used standard power-of-two region and scale, so our level calculations were valid.
        // Ensures that no tiles are generated (and cached forever!) at odd dimensions that we didn't intend to serve up.
        if (level > il) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_LEVEL_MAX,
                    "region and scale correspond to zoom level "+level+" above this image's max of "+il);
        } else if (rx % rs != 0 || ry % rs != 0) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_REGION_BOUNDARY_COORDS,
                    "region rx and ry coords "+rx+","+ry+" must fall evenly on boundary of "+rs+" when zoom level is"+level);
        } else if (rh != Math.min(ih-ry, rs)) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_REGION_HEIGHT,
                    "region height "+rh+" should be "+Math.min(ih-ry, rs)+" when region size is "+rs
                    +" and bottom edge is "+Integer.toString(ih - ry)+" away");
        } else if (rw != Math.min(iw-rx, rs)) {
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_REGION_WIDTH,
                    "region width "+rw+" should be "+Math.min(iw-rx, rs)+" when region size is "+rs
                     +" and right edge is "+Integer.toString(iw - rx)+" away");
        } else if (sh != -1 && Math.abs(explicitSh - sh) > 1) {
            // rarely--I've only seen it at level <= 1—-OSD rounds up when should round down, so allow 1 margin before error
            final float raw = (float)(TILE_SIZE*(ih-ry))/(float)rs;
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_SCALED_HEIGHT,
                    "scaled height "+sh+" should be "+explicitSh+" when right edge is "+df.format(raw)
                    +" (~"+Math.round(raw)+" away after scaling)");
        } else if (sw != -1 && Math.abs(explicitSw - sw) > 1) {
            // rarely--I've only seen it at level <= 1—-OSD rounds up when should round down, so allow 1 margin before error
            final float raw = (float)(TILE_SIZE*(iw-rx))/(float)rs;
            throw new IIIFException(HttpServletResponse.SC_BAD_REQUEST, EM_SCALED_WIDTH,
                    "scaled width "+sw+" should be "+explicitSw+" when bottom edge is "+df.format(raw)
                    +" (~"+Math.round(raw)+" away after scaling)");
        }

        // make scale dimensions explicit -- it's required by Djatoka when using level (and overwrites minor OSD rounding flaws)
        scale.setExplicit(explicitSw, explicitSh);

        return level;
    }

    /**
     * Quick utility function to take log base 2 of a positive int.
     * @param n int to take log2 of
     * @return log2 of the int.
     */
    private static int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    /**
     * Quick utility function to determine whether a positive int is an exact power of 2
     * @param n number to check
     * @return whether n is a power of 2
     */
    private static boolean isExactPowerOf2(int n) {
        return (n & (n-1)) == 0;
    }

    /**
     * Gets basic metadata for the named image, whether from a stored file or a live Djatoka request.
     * After calling, there will be a metadata.xml file in the image's tile cache directory to
     * speed things up next time.
     * If this has been called recently for this item, it doesn't even need the metadata.xml file;
     * it uses an in-memory cache for basically no work.
     * @param id the identifier of the image to look up
     * @return an ImageInfo for the named image
     * @throws IIIFException if anything couldn't be looked up, read, or written
     */
    private ImageInfo getImageInfoWithCaching(final String id) throws IIIFException {

        // check for cached value
        ImageInfo imageInfo = (recentImageInfo==null)?null : recentImageInfo.get(id);

        if (imageInfo == null) {
            PairtreeObject cacheObject;
            try {
                cacheObject = tileCache.getObject(id);
            } catch (IOException e) {
                throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_TILECACHE_ACCESS, e);
            }
            final String filename = PairtreeUtils.encodeID(id);

            // check for existing metadata.xml, and either read it or fetch data and create it
            final File xmlFile = new File(cacheObject, filename + ".xml");
            if (xmlFile.exists() && xmlFile.length() > 0) {
                imageInfo = readMetadataFile(id, xmlFile);
            } else {
                //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles
                imageInfo = fetchMetadata(id, internalServer);
                writeMetadataFile(xmlFile, imageInfo);
            }

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Returning height/width/levels: {}/{}/{}", imageInfo.getHeight(), imageInfo.getWidth(), imageInfo.getLevels());
            }
        }

        if (recentImageInfo != null) {
            recentImageInfo.put(id, imageInfo); // save or update last access time in cache
        }
        return imageInfo;
    }

    /**
     * Makes a connection to the resolver servlet on this server and retrieves image height, width,
     * and levels.
     * @param id image identifier to ask about
     * @param serverName a name to access this server: may be internal or public, so long as it works.
     * @return an ImageInfo for the named image, with values fetched from serverName using a Djatoka
     *         metadata query
     * @throws IIIFException if couldn't connect and read values successfully
     */
    private ImageInfo fetchMetadata(String id, String serverName) throws IIIFException {
        // Construct URL and query for the "resolver" servlet on this same server, but don't omit contextPath
        // because we'll be dispatching it externally to this webapp.
        URL url;
        try {
            url = new URL(serverName + contextPath + resolverPath
                          + StringUtils.format(RESOLVE_METADATA_QUERY, URLEncode.pathSafetyEncode(id)));
        } catch (MalformedURLException e) {
            // "couldn't refer to resolver"
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_CONFIG, e);
        }

        // Retrieve and parse JSON
        // Ideally, I could just call the code directly, but the config and init setup for the
        //   Djatoka code isn't quite worth messing with.
        JsonNode json;
        HttpURLConnection conn = null;
        InputStream connIn = null;
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Querying image metadata: {}", url);
        }
        try {
            // get connection directly so we can better handle error status codes
            conn = (HttpURLConnection)url.openConnection();
            conn.setConnectTimeout(10000); // 10 sec == 10000 ms. Don't freeze forever if the resolver hangs somehow
            conn.setReadTimeout(10000);
            if (conn.getResponseCode()==HttpServletResponse.SC_NOT_FOUND) {
                throw new IIIFException(HttpServletResponse.SC_NOT_FOUND, EM_RESOLVER_NOT_FOUND);
            } else if (conn.getResponseCode() >= 400) {
                throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_IMAGE_FETCH,
                        "error "+conn.getResponseCode()+" in resolver");
            } // if 30X code (redirect) or something, I guess it either works or it doesn't.

            connIn = conn.getInputStream();
            json = MAPPER.readTree(connIn); // read before closing input stream in finally{}
        } catch (IOException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_METADATA_FETCH, e);
        } finally {
            IOUtils.closeQuietly(connIn);
            if (conn != null) {
                conn.disconnect();
            }
        }
        return new ImageInfo(id, json.get("height").asInt(), json.get("width").asInt(), json.get("levels").asInt());
    }

    /**
     * Reads a metadata XML file for an image's height, width, and levels.
     * If values are missing or not integers, defaults to 0.
     * @param id the identifier of the image whose metadata file we're reading
     * @param xmlFile file (matching template.xml) with the values. File must exist.
     * @return an ImageInfo for the named image, with values read from xmlFile
     * @throws IIIFException if couldn't read the file
     */
    private ImageInfo readMetadataFile(String id, File xmlFile) throws IIIFException {
        int width = 0, height = 0, levels = 0; // default values

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Reading XML metadata file: " + xmlFile.getAbsolutePath());
        }

        Document xml;
        try {
            xml = new Builder().build(xmlFile);
        } catch (IOException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_METADATA_XML_READ, e);
        } catch (ParsingException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_METADATA_XML_INVALID, e);
        }
        final Element root = xml.getRootElement();
        final Element sElement = root.getFirstChildElement("Size");
        final String wString = sElement.getAttributeValue("Width");
        final String hString = sElement.getAttributeValue("Height");
        final Element lElement = root.getFirstChildElement("Levels");

        try {
            width = wString.equals("") ? 0 : Integer.parseInt(wString);
            height = hString.equals("") ? 0 : Integer.parseInt(hString);
            if (lElement != null) {
                    levels = Integer.parseInt(lElement.getValue());
            }
        } catch (final NumberFormatException details) {
            if (LOGGER.isWarnEnabled()) {
                LOGGER.warn("Stored height, width, or levels is not an integer. Got h/w/l={},{},{}",height, width, levels);
            }
        }

        return new ImageInfo(id, height, width, levels);
    }

    /**
     * Takes an image's simple metadata and writes it to a file
     * @param xmlFile the metadata.xml file for an image to write to, patterned after a template
     * @param imageInfo an ImageInfo with values for the image whose metadata.xml we're writing
     * @throws IIIFException if couldn't read the template or write the data
     */
    private void writeMetadataFile(File xmlFile, ImageInfo imageInfo) throws IIIFException {
        InputStream inStream = null;
        OutputStream outStream = null;
        try {

            // input is template xml file
            Document templateXml;
            try {
                inStream = getServletContext().getResource(XML_TEMPLATE).openStream();
                templateXml = new Builder().build(inStream);
            } catch (IOException e) {
                throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_TEMPLATE_XML_READ, e);
            } catch (ParsingException e) {
                throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_TEMPLATE_XML_INVALID, e);
            }

            // output is metadata.xml for image
            if (xmlFile.exists()) {
                // delete existing empty file
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("XML metadata file exists: {}", xmlFile);
                }
                if (!xmlFile.delete() && LOGGER.isWarnEnabled()) {
                    LOGGER.warn("File not deleted: {}", xmlFile);
                }
            }

            // populate the template with values from the retrieved JSON
            final Element root = templateXml.getRootElement();
            final Element sElement = root.getFirstChildElement("Size");
            final Attribute hAttribute = sElement.getAttribute("Height");
            final Attribute wAttribute = sElement.getAttribute("Width");
            final Element lElement = root.getFirstChildElement("Levels");

            hAttribute.setValue(Integer.toString(imageInfo.getHeight()));
            wAttribute.setValue(Integer.toString(imageInfo.getWidth()));
            lElement.appendChild(Integer.toString(imageInfo.getLevels()));

            // copy from populated template (backed by inStream) to image's metatada file (backed by outStream)
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Creating new xml metadata file: " + xmlFile.getAbsolutePath());
            }
            try {
                outStream = new FileOutputStream(xmlFile);
                final Serializer serializer = new Serializer(outStream);
                serializer.write(templateXml);
                serializer.flush();
            } catch (IOException e) {
                throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_METADATA_XML_WRITE, e);
            }
        } finally {
            IOUtils.closeQuietly(outStream);
            IOUtils.closeQuietly(inStream);
        }
    }

    /**
     * Serves an image with requested params. Uses a tile in the tilecache already if possible.
     * Otherwise, forward the request to Djatoka OpenURL to make and serve the tile, then move
     * Djatoka's generated image file from its cache into our tilecache for next time.
     *
     * @param aID identifier of image
     * @param aLevel level of sample region
     * @param aRegion sample region
     * @param aScale scale/size of output tile
     * @param aRotation rotation of output tile
     * @param aRequest HTTP request being fulfilled
     * @param aResponse HTTP response to serve on
     * @return the filename of a locally cached copy of the image, or null
     * @throws IIIFException if couldn't read tilecache or dispatch request to OpenURL successfully
     */
    private String serveImageWithCaching(final String aID, final int aLevel, final Region aRegion,
                                         final Size aScale, final float aRotation,
                                         final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IIIFException {
        PairtreeObject cacheObject;
        try {
            cacheObject = tileCache.getObject(aID);
        } catch (IOException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_TILECACHE_ACCESS, e);
        }
        final String fileName = CacheUtils.getFileName(aLevel, aRegion, aScale, aRotation);
        final File imageFile = new File(cacheObject, fileName);

        if (imageFile.exists()) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} serving from Pairtree cache", imageFile);
            }

            serveJpgFile(imageFile.getAbsolutePath(), aResponse);
            return imageFile.getAbsolutePath();
        } else {
            //TODO: make property for whether to allow cache misses, for example when always pre-generating tiles
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("{} not found in cache", imageFile);
            }

            serveNewImage(aID, aLevel, aRegion, aScale, aRotation, aRequest, aResponse);
            return cacheNewImage(aRequest, aID + "_" + fileName, imageFile);
        }
    }

    /**
     * Serve a JPEG file's contents, given its full path
     * @param imagePath path to a JPG image file. File must exist!
     * @param aResponse response to serve the bits on
     * @throws IIIFException if couldn't serve file
     */
    private void serveJpgFile(final String imagePath, final HttpServletResponse aResponse) throws IIIFException {
        final File imageFile = new File(imagePath);
        ServletOutputStream outStream = null;
        try {
            outStream = aResponse.getOutputStream();

            aResponse.setHeader("Content-Length", "" + imageFile.length());
            aResponse.setHeader("Cache-Control", "public, max-age=4838400"); // note: when Djatoka serves, it doesn't include this one!
            aResponse.setContentType("image/jpg");

            IOUtils.copyStream(imageFile, outStream);
        } catch (IOException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_SEND_IMAGE, e);
        } finally {
            IOUtils.closeQuietly(outStream);
        }
    }

    /**
     * Builds the correct query string and dispatches to the OpenURL/Djatoka system to fetch, adjust, and serve
     * the image. As a side effect, the Djatoka system stores its cached file's filename in the session object.
     * @param aID identifier of image
     * @param aLevel level of sample region
     * @param aRegion sample region
     * @param aScale scale/size of output tile
     * @param aRotation rotation of output tile
     * @param aRequest HTTP request being fulfilled
     * @param aResponse HTTP response to serve on
     * @throws IIIFException if couldn't dispatch request to OpenURL successfully
     */
    private void serveNewImage(final String aID, final int aLevel, final Region aRegion, final Size aScale,
                                      final float aRotation, final HttpServletRequest aRequest, final HttpServletResponse aResponse)
            throws IIIFException {
        final String safeID = URLEncode.pathSafetyEncode(aID);
        RequestDispatcher dispatcher;
        String[] values;
        String url;

        // Cast floats as integers because that's what djatoka expects
        // Construct URLs without contextPath because we'll be dispatching them *within* this webapp.
        if (aLevel > 0) {
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, String.valueOf(aLevel), Integer.toString((int) aRotation),
                    aRegion.toDjatokaString(aLevel, aScale) };
            url = resolverPath +StringUtils.format(RESOLVE_IMAGE_QUERY, values);
        } else {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Image requested with no level specified: id={} region={} scale={}", aID, aRegion, aScale);
            }
            values = new String[] { safeID, DEFAULT_VIEW_FORMAT, aRegion.toDjatokaString(aLevel, aScale), aScale.toDjatokaString(),
                    Integer.toString((int) aRotation) };
            url = resolverPath +StringUtils.format(RESOLVE_REGION_QUERY, values);
        }

        // Right now we just let the OpenURL interface do the work
        dispatcher = aRequest.getRequestDispatcher(url);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Image requested: {} - {}", aID, url);
        }

        try {
            dispatcher.forward(aRequest, aResponse);
        } catch (IOException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_RESOLVER_DISPATCH, e);
        } catch (ServletException e) {
            throw new IIIFException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, EM_RESOLVER_DISPATCH, e);
        }
    }

    /**
     * For an image that was just served by the OpenURL/Djatoka system, move its file from their cache to ours.
     * @param aRequest the incoming image request that Djatoka just fulfilled
     * @param aKey the image ID + underscore + and the combined display parameters, which match what Djatoka just served.
     * @param aDestFile the destination file in the tile cache PairTree to which to move the served image tile.
     * @return the filename of a locally cached copy of the image, or null
     */
    private String cacheNewImage(final HttpServletRequest aRequest, final String aKey, final File aDestFile) {
        final HttpSession session = aRequest.getSession();
        // path to temp file that the djatoka code saved in its temp cache (not the freelib tile cache!)
        final String fileName = (String) session.getAttribute(aKey);

        if (fileName != null) {
            // name by which to reference the cached file when talking to OpenURL code
            final String cacheName = (String) session.getAttribute(fileName);
            final File cachedFile = new File(fileName);

            // This moves the newly created file from the adore-djatoka cache
            // to the freelib-djatoka tile cache (which is pure-FS/Pairtree-based)
            if (cachedFile.exists() && aDestFile != null) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("Renaming cache file from {} to {}", cachedFile, aDestFile);
                }

                if (!cachedFile.renameTo(aDestFile) && LOGGER.isWarnEnabled()) {
                    LOGGER.warn("Unable to move cache file: {}", cachedFile);
                } else {
                    // This is the temp file cache used by the OpenURL layer
                    if (!OpenURLJP2KService.removeFromTileCache(cacheName) && LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Unable to remove OpenURL cache file link: {}", fileName);
                    } else {
                        session.removeAttribute(aKey);
                        session.removeAttribute(fileName);
                        return aDestFile.getAbsolutePath();
                    }
                }
            } else if (LOGGER.isWarnEnabled() && !cachedFile.exists()) {
                LOGGER.warn("Session had a cache file ({}), but it didn't exist", cachedFile.getAbsoluteFile());
            } else if (LOGGER.isWarnEnabled()) {
                LOGGER.warn("Location for destination cache file was null");
            }
        } else if (LOGGER.isWarnEnabled()) {
            // If you're wondering why you found your way to this error, it's because something in the Djatoka code
            // had an error. Maybe try turning on debug logging for gov.lanl.* or finding out what URL was
            // dispatched to and loading it directly yourself to see what it reports.
            LOGGER.warn("Couldn't cache ({} = {}); session lacked new image information", aKey, aDestFile
                    .getAbsolutePath());
        }
        return null;
    }

    /**
     * Returns a URL to the root of the server that a request was sent to
     * @param aRequest incoming request
     * @return externally visible address of the server, with explicit port number
     */
    private String getServer(final HttpServletRequest aRequest) {
        final StringBuilder server = new StringBuilder();
        server.append(aRequest.getScheme()).append("://");
        server.append(aRequest.getServerName()).append(":");
        server.append(aRequest.getServerPort());
        return server.toString();
    }

    /**
     * Small utility class to override one method in LinkedHashMap, and make sure the right
     * initializer params get called. This allows it to be used as an LRU cache.
     * @param <K>Key type
     * @param <V>Value type
     */
    private static class LruCache<K,V> extends LinkedHashMap<K,V> {
        private final int maxEntries;
        public LruCache(final int maxEntries) {
            super(maxEntries + 1,0.75f, true);
            this.maxEntries = maxEntries;
        }
        @Override
        protected boolean removeEldestEntry(final Map.Entry<K,V> eldest) {
            return super.size() > maxEntries;
        }
    }
}
